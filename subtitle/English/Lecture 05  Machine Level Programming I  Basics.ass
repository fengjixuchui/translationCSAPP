[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 05  Machine Level Programming I  Basics.mp4
Video File: ../../../../Desktop/csapp/Lecture 05  Machine Level Programming I  Basics.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.125000
Scroll Position: 843
Active Line: 854
Video Position: 131976

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.82,English,,0,0,0,,Good afternoon everyone
Dialogue: 0,0:00:05.48,0:00:10.40,English,,0,0,0,,So now we're going to jump into the part of the course that I'd call the real core of course
Dialogue: 0,0:00:10.40,0:00:14.32,English,,0,0,0,,Where we go into machine level programming
Dialogue: 0,0:00:14.32,0:00:17.18,English,,0,0,0,,And by the term machine level programming I mean
Dialogue: 0,0:00:17.70,0:00:26.24,English,,0,0,0,,When you're actually considering the individual instructions to get executed by the machine in response to your program
Dialogue: 0,0:00:26.54,0:00:29.64,English,,0,0,0,,And there's really two forms of machine programs
Dialogue: 0,0:00:29.64,0:00:33.44,English,,0,0,0,,One is the actual object code that runs on the computer
Dialogue: 0,0:00:33.62,0:00:39.92,English,,0,0,0,,And as we'll see that's a series of bytes that encode instructions that the processor executes
Dialogue: 0,0:00:40.46,0:00:48.40,English,,0,0,0,,But well,because it's hard to look at bytes and understand them there's various text forms to make it more clear
Dialogue: 0,0:00:48.88,0:00:54.86,English,,0,0,0,,And one of  those is assembly code that used to be that's how people program machines
Dialogue: 0,0:00:54.86,0:01:00.10,English,,0,0,0,,And nowadays it's what the target of a compiler is to generate assembly code
Dialogue: 0,0:01:00.40,0:01:01.86,English,,0,0,0,,And I'll use those terms
Dialogue: 0,0:01:01.86,0:01:10.12,English,,0,0,0,,When I say machine code,I sort of interchangeably mean object code the binary form or assembly code the text version of it
Dialogue: 0,0:01:10.58,0:01:14.58,English,,0,0,0,,Interchangeably because it really is a one-to-one mapping between them
Dialogue: 0,0:01:14.76,0:01:19.56,English,,0,0,0,,But in case,I sort of use a term like assembly code
Dialogue: 0,0:01:19.76,0:01:22.76,English,,0,0,0,,When I instead of consistently saying machine code
Dialogue: 0,0:01:22.78,0:01:25.14,English,,0,0,0,,It's because they're really the same general idea
Dialogue: 0,0:01:26.12,0:01:29.56,English,,0,0,0,,So this is sort of one place where
Dialogue: 0,0:01:29.94,0:01:35.50,English,,0,0,0,,This course 213/513 takes a particular perspective
Dialogue: 0,0:01:35.50,0:01:38.72,English,,0,0,0,,That's very different from done ever elsewhere
Dialogue: 0,0:01:39.18,0:01:41.54,English,,0,0,0,,In the bad old days of computing
Dialogue: 0,0:01:42.02,0:01:46.74,English,,0,0,0,,You would be required to take a course it was typically called assembly level programming
Dialogue: 0,0:01:47.34,0:01:50.26,English,,0,0,0,,The way you actually learn to write programs in assembler
Dialogue: 0,0:01:50.74,0:01:58.52,English,,0,0,0,,And your assignments would be to do things like to sort a array of numbers
Dialogue: 0,0:01:58.52,0:02:03.30,English,,0,0,0,,Who set up some kind of linked list data structure  just sort of low-level programming
Dialogue: 0,0:02:03.30,0:02:06.94,English,,0,0,0,,That nowadays you wouldn't even think of wanting to write an assembly code
Dialogue: 0,0:02:07.68,0:02:12.34,English,,0,0,0,,And so people didn't really enjoy those courses very well
Dialogue: 0,0:02:12.66,0:02:15.32,English,,0,0,0,,And so they got sort of our we cut out of the curriculum
Dialogue: 0,0:02:15.76,0:02:17.88,English,,0,0,0,,But what our version of it is...
Dialogue: 0,0:02:18.26,0:02:20.78,English,,0,0,0,,This is pretty important stuff to know
Dialogue: 0,0:02:21.12,0:02:25.98,English,,0,0,0,,As the sort of gateway between what's how you write your programs
Dialogue: 0,0:02:25.98,0:02:28.20,English,,0,0,0,,And C or any other language
Dialogue: 0,0:02:28.58,0:02:31.40,English,,0,0,0,,And how those programs actually execute on a machine
Dialogue: 0,0:02:32.08,0:02:35.30,English,,0,0,0,,So machine code is sort of the intermediate form there
Dialogue: 0,0:02:35.30,0:02:39.46,English,,0,0,0,,The intermediate language and you need to understand that to understand better
Dialogue: 0,0:02:39.74,0:02:41.86,English,,0,0,0,,What your programs are trying to do
Dialogue: 0,0:02:42.32,0:02:44.84,English,,0,0,0,,And what the machine is trying to do
Dialogue: 0,0:02:45.60,0:02:49.18,English,,0,0,0,,So as a result of that our perspective will be
Dialogue: 0,0:02:49.18,0:02:52.72,English,,0,0,0,,We won't actually write except in very very small amounts
Dialogue: 0,0:02:53.22,0:02:57.32,English,,0,0,0,,We're not going to actually sit down and write assembly programs in this course
Dialogue: 0,0:02:57.96,0:03:01.04,English,,0,0,0,,But what you'll do is,you're going to look at a lot of code
Dialogue: 0,0:03:01.38,0:03:04.38,English,,0,0,0,,That was generated by a C compiler gcc
Dialogue: 0,0:03:05.08,0:03:11.04,English,,0,0,0,,And try to see how does that what came out of that compiler relate to what went into it
Dialogue: 0,0:03:11.04,0:03:18.72,English,,0,0,0,,How does this low-level code implement the higher level constructs
Dialogue: 0,0:03:18.72,0:03:21.70,English,,0,0,0,,That I was trying to express my program in
Dialogue: 0,0:03:22.28,0:03:26.92,English,,0,0,0,,How our procedures functions implemented in machine language
Dialogue: 0,0:03:26.92,0:03:29.91,English,,0,0,0,,How our data structures such as arrays and struts
Dialogue: 0,0:03:30.52,0:03:33.92,English,,0,0,0,,How are those implemented in machine codes
Dialogue: 0,0:03:33.92,0:03:35.60,English,,0,0,0,,So we're going to learn all of that stuff
Dialogue: 0,0:03:35.96,0:03:39.14,English,,0,0,0,,And it takes a significant chunk of this course
Dialogue: 0,0:03:39.58,0:03:42.38,English,,0,0,0,,And a fair number of lectures to get through all that material
Dialogue: 0,0:03:42.38,0:03:43.56,English,,0,0,0,,Because it's really quite a bit
Dialogue: 0,0:03:44.42,0:03:50.52,English,,0,0,0,,But I think this is sort of the core of where this course is
Dialogue: 0,0:03:52.78,0:04:00.72,English,,0,0,0,,And as you know in this course we only look at one particular class of machines
Dialogue: 0,0:04:00.72,0:04:07.12,English,,0,0,0,,Even though there's many more different machine level programming possibilities out there
Dialogue: 0,0:04:07.12,0:04:12.72,English,,0,0,0,,And we've chosen the intel the 64-bit version of the intel instruction set
Dialogue: 0,0:04:13.46,0:04:18.50,English,,0,0,0,,So I'll go through a little bit of the history behind intel and how it got to where it is
Dialogue: 0,0:04:19.74,0:04:25.56,English,,0,0,0,,We'll look at through this idea of how does C code relate to assembly code machine code and so forth
Dialogue: 0,0:04:26.36,0:04:33.94,English,,0,0,0,,We'll go through set of low-level basics that you need to understand the of what assembly code,machine code looks like
Dialogue: 0,0:04:34.28,0:04:40.48,English,,0,0,0,,And then we'll actually take on and look at some real code ,focusing specifically on arithmetic operations
Dialogue: 0,0:04:42.86,0:04:48.66,English,,0,0,0,,So x86 is sort of a colloquial term for intel processors
Dialogue: 0,0:04:48.66,0:04:51.66,English,,0,0,0,,And the reason is that the first one was called the 8086
Dialogue: 0,0:04:52.80,0:04:58.65,English,,0,0,0,,And then they kind of skipped 81, but then they went to 80 to 86
Dialogue: 0,0:04:58.65,0:05:01.50,English,,0,0,0,,And so forth 8386
Dialogue: 0,0:05:01.56,0:05:06.84,English,,0,0,0,,So the one thing in common was 86  and so people just call it x86
Dialogue: 0,0:05:07.74,0:05:13.78,English,,0,0,0,,And one thing that's important to this and it will have influence on what the programs look like is
Dialogue: 0,0:05:14.28,0:05:17.06,English,,0,0,0,,X86 is a language like english
Dialogue: 0,0:05:17.18,0:05:24.76,English,,0,0,0,,That it's been an accrual and evolution of different features layered on top of each other
Dialogue: 0,0:05:25.30,0:05:27.84,English,,0,0,0,,And not always the most elegant way
Dialogue: 0,0:05:28.24,0:05:32.70,English,,0,0,0,,So just like english there's all these sort of quirky things
Dialogue: 0,0:05:32.70,0:05:35.80,English,,0,0,0,,That how you write it is very different from how you pronounce it
Dialogue: 0,0:05:36.04,0:05:38.16,English,,0,0,0,,Then there's all these irregular cases
Dialogue: 0,0:05:38.50,0:05:41.94,English,,0,0,0,,It doesn't make sense it's not sort of a purpose-designed language
Dialogue: 0,0:05:42.40,0:05:44.06,English,,0,0,0,,It's the same with x86
Dialogue: 0,0:05:44.06,0:05:46.32,English,,0,0,0,,It's a language that just got there
Dialogue: 0,0:05:46.32,0:05:50.96,English,,0,0,0,,Because of a bunch of decisions that locally were probably the right thing to do
Dialogue: 0,0:05:50.96,0:05:52.00,English,,0,0,0,,But globally were not
Dialogue: 0,0:05:52.52,0:05:56.36,English,,0,0,0,,There's other instruction sets that are much cleaner and easier to understand
Dialogue: 0,0:05:56.70,0:06:04.00,English,,0,0,0,,But we figure it's just the same reason that you learn english instead of learning esperanto or something like that
Dialogue: 0,0:06:04.46,0:06:06.44,English,,0,0,0,,That it's a much more useful language
Dialogue: 0,0:06:09.18,0:06:12.28,English,,0,0,0,,X86 is what sometimes was called a CISC
Dialogue: 0,0:06:12.90,0:06:19.84,English,,0,0,0,,There's a big thing in the early 80s.80s in general called RISC vs. CISC
Dialogue: 0,0:06:20.46,0:06:23.90,English,,0,0,0,,CISC a well risk was a relatively new idea
Dialogue: 0,0:06:23.90,0:06:28.54,English,,0,0,0,,What they called a reduced instruction set computer and it was all the rage
Dialogue: 0,0:06:28.98,0:06:31.54,English,,0,0,0,,And nobody had a name for what came before
Dialogue: 0,0:06:31.54,0:06:35.40,English,,0,0,0,,But the RSIC people named what came before a CISC
Dialogue: 0,0:06:35.96,0:06:41.24,English,,0,0,0,,For complex instruction set computer with the obvious sort of pejorative nature to that title
Dialogue: 0,0:06:41.68,0:06:46.38,English,,0,0,0,,And so intel to the the classic CISC architecture
Dialogue: 0,0:06:46.38,0:06:51.68,English,,0,0,0,,Meaning it has a ton of features we're not going to even scratch the surface if you want it
Dialogue: 0,0:06:52.00,0:06:55.42,English,,0,0,0,,The manual for it is two big fat books
Dialogue: 0,0:06:56.04,0:07:00.78,English,,0,0,0,,Which nowadays you do with pdf documents but it's still a huge amount of stuff
Dialogue: 0,0:07:01.18,0:07:04.38,English,,0,0,0,,Some 500 or more instructions
Dialogue: 0,0:07:04.68,0:07:09.98,English,,0,0,0,,Everything from doing decimal arithmetic to even decimal floating point
Dialogue: 0,0:07:09.98,0:07:12.14,English,,0,0,0,,And all kinds of goofy stuff in there
Dialogue: 0,0:07:13.38,0:07:17.24,English,,0,0,0,,But it turns out that you can kind of get a pretty good handle on it
Dialogue: 0,0:07:17.24,0:07:20.84,English,,0,0,0,,By focusing more on just what does the code look like that
Dialogue: 0,0:07:21.08,0:07:25.46,English,,0,0,0,,GCC is generating for the kind of programs that you typically write
Dialogue: 0,0:07:27.62,0:07:30.06,English,,0,0,0,,And it should also realize it
Dialogue: 0,0:07:30.70,0:07:40.36,English,,0,0,0,,It many levels of this should not have been the successful design
Dialogue: 0,0:07:40.36,0:07:43.30,English,,0,0,0,,Because as I said it's just got lots of stuff on there
Dialogue: 0,0:07:43.78,0:07:48.34,English,,0,0,0,,But intel has been such a powerful company and had so much market
Dialogue: 0,0:07:48.66,0:07:51.12,English,,0,0,0,,And such better technology
Dialogue: 0,0:07:51.12,0:07:53.54,English,,0,0,0,,As far as semiconductors than its competitors
Dialogue: 0,0:07:53.98,0:07:59.56,English,,0,0,0,,That's been able to kind of keep this thing alive for almost 40 years
Dialogue: 0,0:08:00.08,0:08:01.34,English,,0,0,0,,It's pretty admirable
Dialogue: 0,0:08:03.76,0:08:06.12,English,,0,0,0,,So just to give you a sort of timescale
Dialogue: 0,0:08:06.12,0:08:09.30,English,,0,0,0,,As I mentioned the 8086 was the first
Dialogue: 0,0:08:09.30,0:08:15.10,English,,0,0,0,,One of the first single chip 16-bit microprocessors  came out in (19)78
Dialogue: 0,0:08:15.48,0:08:20.76,English,,0,0,0,,And it a slight variation on it was a very basis for the original IBM pc
Dialogue: 0,0:08:20.78,0:08:24.96,English,,0,0,0,,Which I know predates most of you your lives
Dialogue: 0,0:08:24.96,0:08:33.30,English,,0,0,0,,But it was sort of a the the big breakthrough that put computers on the desktops of many people
Dialogue: 0,0:08:35.08,0:08:41.30,English,,0,0,0,,And there's been many many generations I'm just giving you the highlights relevant to this particular class
Dialogue: 0,0:08:41.90,0:08:49.60,English,,0,0,0,,The 386 which dates back to 1985 was the one that really made the transition from these being personal computers
Dialogue: 0,0:08:49.60,0:08:52.96,English,,0,0,0,,That could run not very interesting applications
Dialogue: 0,0:08:53.48,0:08:57.70,English,,0,0,0,,To ones that could actually run something like a unix or linux machine
Dialogue: 0,0:08:58.42,0:09:01.18,English,,0,0,0,,And the reason is they extended it to 32-bit
Dialogue: 0,0:09:01.46,0:09:06.00,English,,0,0,0,,And they removed some of the weird addressing stuff that used to be in there
Dialogue: 0,0:09:06.38,0:09:09.78,English,,0,0,0,,So that these look like sort of a generic a processor
Dialogue: 0,0:09:10.56,0:09:16.84,English,,0,0,0,,And that was clear back in (19)85 and that was what sometimes called IA32 intel architecture 32
Dialogue: 0,0:09:17.48,0:09:25.42,English,,0,0,0,,Which was the dominant way of code up told just even a few years ago
Dialogue: 0,0:09:25.52,0:09:28.28,English,,0,0,0,,So even up as recently as this past summer
Dialogue: 0,0:09:29.14,0:09:31.54,English,,0,0,0,,This course was teaching IA32
Dialogue: 0,0:09:33.70,0:09:36.70,English,,0,0,0,,And then there and I'll talk about it more later
Dialogue: 0,0:09:36.70,0:09:43.68,English,,0,0,0,,There was a reason in a strange story behind the extension from 32 to 64 bits
Dialogue: 0,0:09:44.10,0:09:46.62,English,,0,0,0,,Which kind of was sneaked in by intel
Dialogue: 0,0:09:47.22,0:09:50.36,English,,0,0,0,,And an odd model the Pentium 4E
Dialogue: 0,0:09:50.36,0:09:53.74,English,,0,0,0,,But you see it was only about 10 years ago
Dialogue: 0,0:09:54.94,0:10:04.32,English,,0,0,0,,And one of the smart things they did with that is that the machines that can run the 64-bit code can also run 32-bit code
Dialogue: 0,0:10:04.84,0:10:10.88,English,,0,0,0,,So they were able to sort of bring out all these machines without everybody having to change over their software
Dialogue: 0,0:10:11.20,0:10:20.62,English,,0,0,0,,And it's taken about that amount of time for the software to largely transition away from 32-bit code to 64-bit code
Dialogue: 0,0:10:22.66,0:10:28.60,English,,0,0,0,,And then for actually fairly interesting reasons
Dialogue: 0,0:10:28.92,0:10:32.98,English,,0,0,0,,You could map how fast a single processor would run
Dialogue: 0,0:10:33.38,0:10:39.26,English,,0,0,0,,And it was climbing up at a pretty steady pace until around 2004
Dialogue: 0,0:10:39.72,0:10:44.98,English,,0,0,0,,And then intel got and all the companies got into serious trouble with the power consumption of their chips
Dialogue: 0,0:10:45.68,0:10:47.48,English,,0,0,0,,They're approaching a hundred watts
Dialogue: 0,0:10:47.52,0:10:50.02,English,,0,0,0,,So imagine a hundred watt light bulb
Dialogue: 0,0:10:50.02,0:10:53.20,English,,0,0,0,,And how much heat that generates inside of a box
Dialogue: 0,0:10:53.60,0:10:57.66,English,,0,0,0,,That you try to blow a fan on really hard to keep it from getting too hot
Dialogue: 0,0:10:58.40,0:11:04.08,English,,0,0,0,,And they were reaching the point where they really couldn't go much beyond a hundred watts
Dialogue: 0,0:11:04.10,0:11:06.94,English,,0,0,0,,And so they sort of got into a power budget problem
Dialogue: 0,0:11:07.40,0:11:10.52,English,,0,0,0,,And as a result they haven't been a to scale up the frequency
Dialogue: 0,0:11:10.52,0:11:16.00,English,,0,0,0,,How fast the inner clock that drives this thing is beyond just a few GHz
Dialogue: 0,0:11:17.42,0:11:21.88,English,,0,0,0,,Since 2004 so what's happened was
Dialogue: 0,0:11:22.24,0:11:25.32,English,,0,0,0,,They said well we can't make any single processor faster
Dialogue: 0,0:11:25.32,0:11:28.18,English,,0,0,0,,But we can put a bunch of processors on a single chip
Dialogue: 0,0:11:28.64,0:11:31.04,English,,0,0,0,,And those are referred to cores or multi-core
Dialogue: 0,0:11:31.58,0:11:36.02,English,,0,0,0,,So most of you with laptops probably have two cores on those
Dialogue: 0,0:11:36.76,0:11:40.88,English,,0,0,0,,And a laptop processor and a server might have up to 16 cores
Dialogue: 0,0:11:42.18,0:11:46.90,English,,0,0,0,,So those are independent processors that are all reside on a single chip
Dialogue: 0,0:11:48.52,0:11:51.64,English,,0,0,0,,The shark machines date back to 2008
Dialogue: 0,0:11:52.40,0:11:55.48,English,,0,0,0,,And they are each have four cores on them
Dialogue: 0,0:11:57.08,0:12:04.10,English,,0,0,0,,The shark machines the one thing about computers haven't really gotten that much faster of in the meantime
Dialogue: 0,0:12:04.10,0:12:10.14,English,,0,0,0,,So there's still fairways and they were in their day a very high-performance machine
Dialogue: 0,0:12:10.14,0:12:11.38,English,,0,0,0,,So they're still pretty decent
Dialogue: 0,0:12:14.82,0:12:19.22,English,,0,0,0,,This shows a picture of the chip that makes up a...
Dialogue: 0,0:12:20.88,0:12:25.66,English,,0,0,0,,I think the the shark machines or approximately that same area
Dialogue: 0,0:12:26.02,0:12:31.68,English,,0,0,0,,And you'll see that as the picture shows these four cores are integrated onto one chip
Dialogue: 0,0:12:32.10,0:12:34.94,English,,0,0,0,,And then down at the bottom is what they call a cache
Dialogue: 0,0:12:35.02,0:12:37.06,English,,0,0,0,,And we'll learn a lot about cache memory but it's
Dialogue: 0,0:12:37.62,0:12:44.62,English,,0,0,0,,It's basically a temporary memory used to hold the most recently accessed data
Dialogue: 0,0:12:44.62,0:12:46.62,English,,0,0,0,,So that you can get to it more quickly
Dialogue: 0,0:12:47.52,0:12:50.08,English,,0,0,0,,And you'll see that that shared across the four cores
Dialogue: 0,0:12:53.02,0:13:00.22,English,,0,0,0,,So if you look at the latest if you were to go off shopping on in the catalog the latest instance
Dialogue: 0,0:13:00.22,0:13:02.06,English,,0,0,0,,And I don't have any chip pictures
Dialogue: 0,0:13:02.62,0:13:04.88,English,,0,0,0,,It is a model they called a broadwell model
Dialogue: 0,0:13:05.54,0:13:09.70,English,,0,0,0,,And you'll see that on a single chip they have multiple cores
Dialogue: 0,0:13:10.74,0:13:16.44,English,,0,0,0,,4 cores a serious standard desktop model eight first a server class machine
Dialogue: 0,0:13:16.88,0:13:22.38,English,,0,0,0,,And then built around the perimeter there are various connections to the rest of the world
Dialogue: 0,0:13:22.88,0:13:28.52,English,,0,0,0,,So DDR is the way you connect to the main memory what's called DRAM dynamic RAM
Dialogue: 0,0:13:29.32,0:13:32.64,English,,0,0,0,,PCI is the connection to peripheral devices
Dialogue: 0,0:13:34.34,0:13:37.38,English,,0,0,0,,SATA is a connection to different types of discs
Dialogue: 0,0:13:38.82,0:13:42.61,English,,0,0,0,,And USB well you know USB is
Dialogue: 0,0:13:44.34,0:13:48.20,English,,0,0,0,,And then the ethernet is the connection also to a network connection
Dialogue: 0,0:13:48.44,0:13:55.74,English,,0,0,0,,So that's all integrated onto a single chip is not just the processor itself
Dialogue: 0,0:13:56.22,0:14:01.76,English,,0,0,0,,But a lot of logic that glues that processor into a larger system
Dialogue: 0,0:14:02.78,0:14:08.24,English,,0,0,0,,And one interesting thing you'll notice is that the desktop model is a higher power 65 watts
Dialogue: 0,0:14:08.84,0:14:10.80,English,,0,0,0,,Versus the server is 45 watts
Dialogue: 0,0:14:10.90,0:14:13.20,English,,0,0,0,,When you put a lot of computers in a room
Dialogue: 0,0:14:13.76,0:14:16.58,English,,0,0,0,,Turns out power is the biggest issue you have to deal with
Dialogue: 0,0:14:21.22,0:14:23.90,English,,0,0,0,,So intel isn't the only company in this game
Dialogue: 0,0:14:24.02,0:14:27.76,English,,0,0,0,,They're sort of historic competitors a company called AMD
Dialogue: 0,0:14:28.32,0:14:33.64,English,,0,0,0,,And AMD was always sort of NO.2 behind intel
Dialogue: 0,0:14:34.52,0:14:37.58,English,,0,0,0,,In all the just so I gave is his NO.2 behind hertz
Dialogue: 0,0:14:38.36,0:14:42.22,English,,0,0,0,,But they are...
Dialogue: 0,0:14:43.58,0:14:48.04,English,,0,0,0,,But they had a little burst in time when they kind of got out ahead of intel
Dialogue: 0,0:14:48.04,0:14:52.38,English,,0,0,0,,Because intel had wasted their time on some bad ideas
Dialogue: 0,0:14:53.08,0:14:58.26,English,,0,0,0,,And they actually were the one that came up with the 64-bit extension to intel that we use
Dialogue: 0,0:15:00.48,0:15:03.28,English,,0,0,0,,Right now though AMD is not doing very well
Dialogue: 0,0:15:03.36,0:15:07.74,English,,0,0,0,,Intel sort of realized that it had to get its act together and it did
Dialogue: 0,0:15:08.20,0:15:10.00,English,,0,0,0,,And is more or less crushed AMD
Dialogue: 0,0:15:12.18,0:15:16.98,English,,0,0,0,,But and I should mention that they had these ferocious patent suits
Dialogue: 0,0:15:17.60,0:15:24.72,English,,0,0,0,,Many years ago and the result of that was a cross licensing deal that allows AMD to produce x86 processors
Dialogue: 0,0:15:26.50,0:15:29.58,English,,0,0,0,,Now it's interesting story behind intel in 64-bit
Dialogue: 0,0:15:30.20,0:15:34.94,English,,0,0,0,,They decided to make this radical shift to an architecture that they called the...
Dialogue: 0,0:15:38.10,0:15:40.96,English,,0,0,0,,They called IA-64 at the time
Dialogue: 0,0:15:41.22,0:15:43.70,English,,0,0,0,,And it was based on a whole new concept
Dialogue: 0,0:15:44.36,0:15:48.98,English,,0,0,0,,That looked really good on paper and initial results look promising
Dialogue: 0,0:15:49.28,0:15:51.18,English,,0,0,0,,They invested a lot of money in this stuff
Dialogue: 0,0:15:51.40,0:15:56.28,English,,0,0,0,,They formed a joint operation with packed on this and it turned out not to work
Dialogue: 0,0:15:56.50,0:16:03.98,English,,0,0,0,,It was much too aggressive it assumed miraculous optimization capabilities by the compiler
Dialogue: 0,0:16:03.98,0:16:08.94,English,,0,0,0,,And so it was a from a technical idea it was very interesting technology
Dialogue: 0,0:16:08.94,0:16:10.86,English,,0,0,0,,But in the marketplace it didn't work
Dialogue: 0,0:16:11.46,0:16:14.16,English,,0,0,0,,And this was sort of a branch off
Dialogue: 0,0:16:14.84,0:16:19.42,English,,0,0,0,,The intel pursued and felt obligated to keep it up because they'd invested so much in it
Dialogue: 0,0:16:19.86,0:16:23.34,English,,0,0,0,,And along came AMD and they said well we don't have to do this radical shift
Dialogue: 0,0:16:23.46,0:16:26.62,English,,0,0,0,,We'll just sort of do the obvious thing of adding
Dialogue: 0,0:16:27.34,0:16:32.20,English,,0,0,0,,Making the registers bigger making things go from 32 to 64 bits
Dialogue: 0,0:16:32.66,0:16:37.08,English,,0,0,0,,And they came along with that and were successful
Dialogue: 0,0:16:37.16,0:16:43.46,English,,0,0,0,,And so intel kind of had to just sheepishly follow behind AMD on this
Dialogue: 0,0:16:43.86,0:16:46.08,English,,0,0,0,,But they could because of their cross licensing deal
Dialogue: 0,0:16:47.06,0:16:54.76,English,,0,0,0,,So nowadays as I mentioned hardware wise just about every processor that is in a laptop,in a desktop
Dialogue: 0,0:16:54.76,0:16:59.12,English,,0,0,0,,Even your cell phones of recent generation are all 64-bit processors
Dialogue: 0,0:17:03.90,0:17:08.06,English,,0,0,0,,So what we'll talk about then we used to teach IA32
Dialogue: 0,0:17:08.06,0:17:12.42,English,,0,0,0,,But that's gone this is the first term where we're skipping it all together
Dialogue: 0,0:17:13.04,0:17:16.82,English,,0,0,0,,So we're using what we'll call x86-64
Dialogue: 0,0:17:16.82,0:17:21.46,English,,0,0,0,,There's various ways this is named,but this is sort of the linux way of naming it
Dialogue: 0,0:17:22.60,0:17:27.64,English,,0,0,0,,If you're interested in IA32 there's a document on the web associated with the book
Dialogue: 0,0:17:27.78,0:17:31.50,English,,0,0,0,,Called a web aside that goes through at least some of the basics of
Dialogue: 0,0:17:31.94,0:17:37.34,English,,0,0,0,,But to really read that you need to learn the 64 bit,because it assumes you kind of already know that
Dialogue: 0,0:17:39.76,0:17:43.76,English,,0,0,0,,Okay so let's go in,and I should mention to just for general interest
Dialogue: 0,0:17:44.26,0:17:48.84,English,,0,0,0,,The other major class of processor and common use today are called ARM
Dialogue: 0,0:17:49.48,0:17:53.82,English,,0,0,0,,So ARM actually is an acronym for acorn RISC machine
Dialogue: 0,0:17:54.66,0:17:58.58,English,,0,0,0,,I just told you what RISC means. It means reduced instruction set computer
Dialogue: 0,0:17:59.04,0:18:04.64,English,,0,0,0,,An acorn means like you know the seed of an oak tree, it was a British company
Dialogue: 0,0:18:04.86,0:18:10.96,English,,0,0,0,,That decided to make its own personal computers in the early days of it and they said
Dialogue: 0,0:18:11.58,0:18:13.18,English,,0,0,0,,We're not going to buy those chips from intel
Dialogue: 0,0:18:13.18,0:18:16.42,English,,0,0,0,,We're going to make them ourselves so they designed and manufactured their own chips
Dialogue: 0,0:18:17.10,0:18:20.62,English,,0,0,0,,Well as a company a computer manufacturer it was a complete bust
Dialogue: 0,0:18:21.32,0:18:26.24,English,,0,0,0,,But it turned out that they'd come up with a fairly good instruction set
Dialogue: 0,0:18:26.32,0:18:32.60,English,,0,0,0,,That was sufficiently simple that it could be put on chips and better yet
Dialogue: 0,0:18:32.60,0:18:33.84,English,,0,0,0,,It could be customized
Dialogue: 0,0:18:34.32,0:18:39.04,English,,0,0,0,,So arm is now a company of its own headquartered in Cambridge England
Dialogue: 0,0:18:39.64,0:18:43.06,English,,0,0,0,,And the reason why part of the reason they're successful therefore is
Dialogue: 0,0:18:43.58,0:18:49.70,English,,0,0,0,,Because it tends to be a lower power than an x86 machine because it's simpler
Dialogue: 0,0:18:50.20,0:18:52.86,English,,0,0,0,,But the other is that they don't actually sell processors
Dialogue: 0,0:18:52.86,0:18:58.86,English,,0,0,0,,They sell companies the rights the licensing rights to use their designs
Dialogue: 0,0:18:59.34,0:19:07.56,English,,0,0,0,,And so if you look at like a a cell phone processor,the actual arm processor is a little tiny part of it on the chip
Dialogue: 0,0:19:08.20,0:19:14.80,English,,0,0,0,,And then they'll have other stuff to make the graphics go better to improve your phone calls and so forth
Dialogue: 0,0:19:14.84,0:19:19.36,English,,0,0,0,,And so they're really selling what intellectual property is as opposed to chips
Dialogue: 0,0:19:20.10,0:19:23.66,English,,0,0,0,,And so people we've gotten various enquiries
Dialogue: 0,0:19:23.66,0:19:28.08,English,,0,0,0,,When are you going to start talking about ARM in your book or your course or something and we go
Dialogue: 0,0:19:28.46,0:19:31.74,English,,0,0,0,,It would be another book to write to do justice to ARM
Dialogue: 0,0:19:31.74,0:19:34.24,English,,0,0,0,,It would be like a whole redo of the thing
Dialogue: 0,0:19:34.58,0:19:37.74,English,,0,0,0,,And we were not inclined to do that right now
Dialogue: 0,0:19:39.32,0:19:44.16,English,,0,0,0,,But just so you know there's sort of a two worlds out there x86
Dialogue: 0,0:19:44.16,0:19:46.06,English,,0,0,0,,ARM are the dominant players right now
Dialogue: 0,0:19:49.46,0:19:54.36,English,,0,0,0,,So let's talk some terminology,if you've probably heard some of these terms before but let's make it clear
Dialogue: 0,0:19:54.91,0:19:58.40,English,,0,0,0,,So when we talk about the instructions the instruction set
Dialogue: 0,0:19:58.96,0:20:06.76,English,,0,0,0,,That's the the target of a compiler to give you a series of instructions that tell the machine exactly what to do
Dialogue: 0,0:20:08.92,0:20:11.50,English,,0,0,0,,But it turns out that the hardware people have figured out
Dialogue: 0,0:20:11.50,0:20:14.60,English,,0,0,0,,All kinds of clever ways to implement instructions
Dialogue: 0,0:20:15.26,0:20:18.96,English,,0,0,0,,Some of them are really fast but take a lot of hardware
Dialogue: 0,0:20:19.48,0:20:22.16,English,,0,0,0,,Some are pretty slow but don't take much hardware at all
Dialogue: 0,0:20:22.64,0:20:28.70,English,,0,0,0,,And so they managed to create this abstraction that's called the instruction set architecture
Dialogue: 0,0:20:28.70,0:20:31.84,English,,0,0,0,,Which is what the target of a compiler should be
Dialogue: 0,0:20:32.12,0:20:35.18,English,,0,0,0,,And then let the hardware people figure out how best to implement it
Dialogue: 0,0:20:35.84,0:20:40.52,English,,0,0,0,,And then the low,so that that's a concept actually it came along in the 1960s
Dialogue: 0,0:20:41.66,0:20:48.30,English,,0,0,0,,So that's even before my time as far as a computer person,but...
Dialogue: 0,0:20:49.10,0:20:52.98,English,,0,0,0,,It's a very important concept in the world of computers
Dialogue: 0,0:20:53.50,0:20:55.92,English,,0,0,0,,And then what they call the lower level stuff
Dialogue: 0,0:20:55.92,0:20:58.80,English,,0,0,0,,How it actually gets implement is called the microarchitecture
Dialogue: 0,0:20:59.12,0:21:02.50,English,,0,0,0,,And we will talk very very little about microarchitecture in this course
Dialogue: 0,0:21:03.54,0:21:07.82,English,,0,0,0,,And as I mentioned machine code is sort of a generic term that incorporates both
Dialogue: 0,0:21:08.26,0:21:14.20,English,,0,0,0,,The actual (bit)bytes that are operated executing as well as the assembly level version of it
Dialogue: 0,0:21:18.26,0:21:22.12,English,,0,0,0,,And as I mentioned you can think of from instruction set point of view
Dialogue: 0,0:21:22.88,0:21:27.74,English,,0,0,0,,So IA32,x86-64 and what's called Itanium
Dialogue: 0,0:21:28.46,0:21:31.20,English,,0,0,0,,This not very successful intel thing
Dialogue: 0,0:21:31.46,0:21:37.28,English,,0,0,0,,Those are all in some ways different instruction set architectures
Dialogue: 0,0:21:37.28,0:21:42.02,English,,0,0,0,,ARM actually similar to intel has gone through various different generations
Dialogue: 0,0:21:42.02,0:21:45.42,English,,0,0,0,,So there's various different generations of its instruction set
Dialogue: 0,0:21:47.82,0:21:51.32,English,,0,0,0,,So from a programmer machine level programmers perspective
Dialogue: 0,0:21:51.74,0:21:55.00,English,,0,0,0,,Things are a bit different than you see when you write C code
Dialogue: 0,0:21:56.24,0:22:01.38,English,,0,0,0,,First of all there is some very visible parts of the instruction the machine state
Dialogue: 0,0:22:02.12,0:22:06.32,English,,0,0,0,,That you can examine and test and operate on and you must in fact
Dialogue: 0,0:22:06.82,0:22:10.92,English,,0,0,0,,You would never understand what those are if you're just thinking in terms of C
Dialogue: 0,0:22:11.88,0:22:17.50,English,,0,0,0,,So in particular there's some sort of a program counter to tells you what
Dialogue: 0,0:22:17.66,0:22:22.62,English,,0,0,0,,What address is the instruction that you're going to execute next
Dialogue: 0,0:22:22.66,0:22:24.38,English,,0,0,0,,Where is that located in memory
Dialogue: 0,0:22:25.40,0:22:33.38,English,,0,0,0,,And then there's a set of registers which are part of that the programmer actually makes use of
Dialogue: 0,0:22:33.38,0:22:38.14,English,,0,0,0,,You can think of them as as a very small number of memory locations
Dialogue: 0,0:22:38.14,0:22:43.28,English,,0,0,0,,But rather than giving an address from 0 up to n-1 or something
Dialogue: 0,0:22:43.50,0:22:47.38,English,,0,0,0,,You actually give them by name as specifically
Dialogue: 0,0:22:48.22,0:22:50.34,English,,0,0,0,,And then there's another sort of state
Dialogue: 0,0:22:50.54,0:22:53.64,English,,0,0,0,,That's just a few bits worth of state that talked about
Dialogue: 0,0:22:54.10,0:22:59.26,English,,0,0,0,,What are the results of some recent instructions
Dialogue: 0,0:22:59.76,0:23:04.26,English,,0,0,0,,Where they did it produce a value of 0,did it produce a negative or a positive value
Dialogue: 0,0:23:04.60,0:23:06.66,English,,0,0,0,,And those are used to implement conditional branching
Dialogue: 0,0:23:06.66,0:23:08.82,English,,0,0,0,,Which we'll look at later as we go
Dialogue: 0,0:23:10.12,0:23:11.60,English,,0,0,0,,And then the other part of it
Dialogue: 0,0:23:11.86,0:23:15.64,English,,0,0,0,,So that's sort of the processor and then the other part of is the memory
Dialogue: 0,0:23:16.20,0:23:21.78,English,,0,0,0,,And as I mentioned in the one of the first lectures
Dialogue: 0,0:23:21.78,0:23:25.56,English,,0,0,0,,The memory is you can think of logically as just an array of bytes
Dialogue: 0,0:23:26.72,0:23:30.50,English,,0,0,0,,And that's what the machine level programmer sees
Dialogue: 0,0:23:31.36,0:23:35.88,English,,0,0,0,,And it's actually kind of a fiction in different ways as I mentioned before
Dialogue: 0,0:23:35.90,0:23:39.24,English,,0,0,0,,There's sort of a collaboration between the operating system and the hardware
Dialogue: 0,0:23:39.68,0:23:45.08,English,,0,0,0,,What they call virtual memory to make it look like each program running on the processor
Dialogue: 0,0:23:45.56,0:23:50.14,English,,0,0,0,,Has its own independent array of bytes that it can access
Dialogue: 0,0:23:51.20,0:23:56.70,English,,0,0,0,,Even though they actually share values within the the physical memory itself
Dialogue: 0,0:23:57.24,0:23:59.40,English,,0,0,0,,And furthermore you heard the term cache
Dialogue: 0,0:24:00.06,0:24:02.76,English,,0,0,0,,The idea of a cache is not visible here at all
Dialogue: 0,0:24:03.28,0:24:06.84,English,,0,0,0,,Because it just is automatically loaded with recent stuff
Dialogue: 0,0:24:08.16,0:24:13.14,English,,0,0,0,,And the only thing that will look different is if you re-access that memory it will go faster
Dialogue: 0,0:24:13.18,0:24:15.18,English,,0,0,0,,Than it would if it hadn't been cached
Dialogue: 0,0:24:15.82,0:24:17.72,English,,0,0,0,,But it's not visible in terms of
Dialogue: 0,0:24:18.04,0:24:20.62,English,,0,0,0,,There's no instructions to manipulate the cache
Dialogue: 0,0:24:20.72,0:24:24.92,English,,0,0,0,,There's no way you can directly access the cache
Dialogue: 0,0:24:26.94,0:24:33.08,English,,0,0,0,,So you already see that it's already abstract it's got some more details of real hardware
Dialogue: 0,0:24:33.50,0:24:39.28,English,,0,0,0,,But underneath it the sort of micro architecture level has some features built into it
Dialogue: 0,0:24:39.64,0:24:45.38,English,,0,0,0,,That you're not operating on you're not making use of directly
Dialogue: 0,0:24:47.30,0:24:49.14,English,,0,0,0,,Yeah when you write machine level programs
Dialogue: 0,0:24:52.84,0:24:57.38,English,,0,0,0,,So if you have a program then say and C
Dialogue: 0,0:24:57.38,0:25:01.58,English,,0,0,0,,It would typically on a larger program that will include multiple files
Dialogue: 0,0:25:02.30,0:25:05.20,English,,0,0,0,,And it will make use of some library code
Dialogue: 0,0:25:05.72,0:25:09.92,English,,0,0,0,,And so the process of compilation is actually a series of steps
Dialogue: 0,0:25:10.68,0:25:12.82,English,,0,0,0,,That will take what you've written for code
Dialogue: 0,0:25:13.34,0:25:17.24,English,,0,0,0,,Turn it into machine code,combine it with the compiled
Dialogue: 0,0:25:18.00,0:25:24.16,English,,0,0,0,,Compiler generated code for the libraries and produce finally a in a file
Dialogue: 0,0:25:24.56,0:25:26.76,English,,0,0,0,,That's your actual executable program
Dialogue: 0,0:25:27.52,0:25:34.24,English,,0,0,0,,And there's shown here in this picture that the first step is to take C and actually generate assembly code from it
Dialogue: 0,0:25:35.20,0:25:38.04,English,,0,0,0,,And then the next is to run that through an assembler
Dialogue: 0,0:25:38.04,0:25:44.84,English,,0,0,0,,Which takes the text representation of instructions and turns it into the actual byte level representation
Dialogue: 0,0:25:45.06,0:25:46.66,English,,0,0,0,,We'll look at all this shortly
Dialogue: 0,0:25:47.56,0:25:50.98,English,,0,0,0,,And then there's a program called a linker
Dialogue: 0,0:25:51.28,0:25:57.28,English,,0,0,0,,Which merges together all the different files for both your individual file
Dialogue: 0,0:25:57.72,0:26:01.99,English,,0,0,0,,Their compiled versions and for the library code
Dialogue: 0,0:26:02.78,0:26:06.28,English,,0,0,0,,And then finally there's a even once you run a program
Dialogue: 0,0:26:06.28,0:26:12.62,English,,0,0,0,,There's actually some libraries that get imported dynamically when the program first begins
Dialogue: 0,0:26:14.16,0:26:17.36,English,,0,0,0,,So it's a sort of many layered set of activities
Dialogue: 0,0:26:17.84,0:26:21.10,English,,0,0,0,,And I'll go through some of these one-by-one for you
Dialogue: 0,0:26:22.58,0:26:28.84,English,,0,0,0,,So for example here's a not very interesting function in terms of doing anything useful
Dialogue: 0,0:26:28.84,0:26:33.22,English,,0,0,0,,But it sort of demonstrates the basic ideas of compilation
Dialogue: 0,0:26:33.68,0:26:36.34,English,,0,0,0,,And if I run this through a C compiler
Dialogue: 0,0:26:37.02,0:26:42.10,English,,0,0,0,,I get something that looks like what's shown on the right and that's assembly code
Dialogue: 0,0:26:43.12,0:26:45.36,English,,0,0,0,,And just to give you an idea of what it is
Dialogue: 0,0:26:45.36,0:26:48.50,English,,0,0,0,,It looks like a sort of strange language the first time you see it
Dialogue: 0,0:26:49.06,0:26:51.44,English,,0,0,0,,But you'll see those percent are
Dialogue: 0,0:26:51.88,0:26:54.54,English,,0,0,0,,Something those are the actual names of registers
Dialogue: 0,0:26:54.66,0:26:57.58,English,,0,0,0,,Remember I told you there's registers that you give by name
Dialogue: 0,0:26:59.28,0:27:02.06,English,,0,0,0,,And then those instructions are telling it to do something
Dialogue: 0,0:27:02.16,0:27:04.98,English,,0,0,0,,Pushq means push something onto a stack
Dialogue: 0,0:27:05.72,0:27:09.10,English,,0,0,0,,Mov means move copy it from one place to another
Dialogue: 0,0:27:09.56,0:27:11.86,English,,0,0,0,,Call means to call some procedure
Dialogue: 0,0:27:12.70,0:27:15.12,English,,0,0,0,,Pop is the counterpart to push
Dialogue: 0,0:27:15.74,0:27:20.32,English,,0,0,0,,And then ret is exit return out of this particular function
Dialogue: 0,0:27:20.32,0:27:24.82,English,,0,0,0,,So you see each of those is an instruction and it's written in text
Dialogue: 0,0:27:24.82,0:27:30.74,English,,0,0,0,,But each of those will turn into one actual instruction in the object code representation
Dialogue: 0,0:27:32.38,0:27:37.58,English,,0,0,0,,So I should tell you that this is actually a slightly cleaned up version of what really happens
Dialogue: 0,0:27:37.60,0:27:41.80,English,,0,0,0,,So let me show you the reality because you'll be experiencing that a bit more too
Dialogue: 0,0:27:47.60,0:28:04.68,English,,0,0,0,,They had this bigger before let me make it bigger
Dialogue: 0,0:28:04.72,0:28:10.42,English,,0,0,0,,And blow this up so that you can see it
Dialogue: 0,0:28:10.48,0:28:12.02,English,,0,0,0,,Can you see it in the back there?
Dialogue: 0,0:28:13.82,0:28:23.70,English,,0,0,0,,Bigger?better?
Dialogue: 0,0:28:23.82,0:28:29.16,English,,0,0,0,,And let me get the other one
Dialogue: 0,0:28:29.20,0:28:50.42,English,,0,0,0,,It's not anyone
Dialogue: 0,0:28:50.44,0:28:56.18,English,,0,0,0,,And they've already logged into a fish machine to get here
Dialogue: 0,0:28:56.18,0:29:01.80,English,,0,0,0,,So this is a file then you see it's called sum.c
Dialogue: 0,0:29:02.26,0:29:07.14,English,,0,0,0,,And I mention that all of these programs are available you can see the whole
Dialogue: 0,0:29:08.26,0:29:14.62,English,,0,0,0,,Well slash afs is my own personal and all that first stuff is my own personal links
Dialogue: 0,0:29:15.18,0:29:17.56,English,,0,0,0,,But once you get to the class webpage
Dialogue: 0,0:29:18.10,0:29:24.34,English,,0,0,0,,Or www slash code slash and then it's all given by which particular lecture it
Dialogue: 0,0:29:25.20,0:29:27.86,English,,0,0,0,,I think these are linked on the home page too
Dialogue: 0,0:29:28.38,0:29:30.04,English,,0,0,0,,And you can see various files there
Dialogue: 0,0:29:30.90,0:29:37.54,English,,0,0,0,,That are used for the demonstration the C files are obviously the programs that we typed in
Dialogue: 0,0:29:37.54,0:29:41.72,English,,0,0,0,,And then once it have an s at the end that's assembly code
Dialogue: 0,0:29:41.72,0:29:44.16,English,,0,0,0,,One that end of d what's called disassembly
Dialogue: 0,0:29:44.94,0:29:57.24,English,,0,0,0,,So anyways if I say gcc -o2 ,I'm sorry. -og -s sum.c
Dialogue: 0,0:29:58.80,0:30:05.68,English,,0,0,0,,That what I did was just tell the compiler to take the C code and turn it into assembly code
Dialogue: 0,0:30:06.14,0:30:10.90,English,,0,0,0,,So when you invoke GCC you're actually invoking it's not just one program
Dialogue: 0,0:30:10.90,0:30:12.50,English,,0,0,0,,But a whole sequence of programs
Dialogue: 0,0:30:13.36,0:30:16.52,English,,0,0,0,,That do various stages of the compilation
Dialogue: 0,0:30:16.88,0:30:20.34,English,,0,0,0,,And by giving it this -s which I'm saying stop
Dialogue: 0,0:30:21.42,0:30:24.20,English,,0,0,0,,I'll just do the first part C to assembly code
Dialogue: 0,0:30:25.66,0:30:33.56,English,,0,0,0,,And the -og is a specification of what kind of optimization I want the compiler to do
Dialogue: 0,0:30:34.22,0:30:36.02,English,,0,0,0,,So if you don't say anything
Dialogue: 0,0:30:36.64,0:30:44.38,English,,0,0,0,,If you just again, it will generate completely unoptimized code and it's actually very hard to read that code
Dialogue: 0,0:30:44.38,0:30:47.92,English,,0,0,0,,It's very tedious the way it works
Dialogue: 0,0:30:48.56,0:30:51.56,English,,0,0,0,,You say -o1
Dialogue: 0,0:30:51.56,0:30:55.76,English,,0,0,0,,Which is what you used to do to turn on the optimizer
Dialogue: 0,0:30:55.96,0:30:59.44,English,,0,0,0,,It turns out that as GCC as they've gotten more advanced
Dialogue: 0,0:30:59.90,0:31:02.22,English,,0,0,0,,It does a lot of optimizations now
Dialogue: 0,0:31:02.66,0:31:07.34,English,,0,0,0,,That for the purpose of this course make the code pretty hard to understand
Dialogue: 0,0:31:07.90,0:31:16.46,English,,0,0,0,,So just with one of the most recent generations of GCC came out with this level called g for debugging
Dialogue: 0,0:31:16.88,0:31:19.46,English,,0,0,0,,That's a nice for this course
Dialogue: 0,0:31:20.22,0:31:26.92,English,,0,0,0,,Purpose of this course a nice level that sort of does the obvious kind of optimizations to make the code readable
Dialogue: 0,0:31:27.16,0:31:30.90,English,,0,0,0,,Without being sort of extravagant and trying to
Dialogue: 0,0:31:31.30,0:31:36.68,English,,0,0,0,,Rewrite your whole program in a way that would make it a lot different  and hopefully more efficient
Dialogue: 0,0:31:37.06,0:31:38.62,English,,0,0,0,,So that's what we'll use in this course
Dialogue: 0,0:31:39.16,0:31:44.30,English,,0,0,0,,It's only exists in the recent versions of GCC it's non-standard across other compilers
Dialogue: 0,0:31:44.32,0:31:45.16,English,,0,0,0,,Question
Dialogue: 0,0:31:45.16,0:31:48.36,English,,0,0,0,,[sutdent speaking]
Dialogue: 0,0:31:48.38,0:31:53.02,English,,0,0,0,,No it's an o capital o,it stands for optimized
Dialogue: 0,0:31:55.84,0:32:00.76,English,,0,0,0,,So what that command just did was produce a file called sum.s
Dialogue: 0,0:32:02.08,0:32:03.38,English,,0,0,0,,So let me show you
Dialogue: 0,0:32:07.28,0:32:11.26,English,,0,0,0,,What sum.s is and let me show you the function some store
Dialogue: 0,0:32:16.24,0:32:28.58,English,,0,0,0,,Can you see that then? okay
Dialogue: 0,0:32:28.58,0:32:32.10,English,,0,0,0,,So this is the code it says some store
Dialogue: 0,0:32:33.12,0:32:36.74,English,,0,0,0,,And then you'll see, you'll recognize those instructions I mentioned before
Dialogue: 0,0:32:36.74,0:32:41.36,English,,0,0,0,,The push,the mov, the call, the mov, the pop and the ret
Dialogue: 0,0:32:41.68,0:32:43.44,English,,0,0,0,,But you also see other junk there
Dialogue: 0,0:32:47.32,0:32:52.02,English,,0,0,0,,That that we edited out for the presentation and even in the book it got edited out
Dialogue: 0,0:32:52.66,0:32:57.74,English,,0,0,0,,And the reason is these are various directives that aren't really directly part of the code itself
Dialogue: 0,0:32:58.20,0:33:04.44,English,,0,0,0,,The fact they start with a period is an indication that these aren't actually instructions they're something else
Dialogue: 0,0:33:04.66,0:33:10.40,English,,0,0,0,,And they all are related to what the information that needs to be fed
Dialogue: 0,0:33:10.98,0:33:16.22,English,,0,0,0,,To a debugger for it to be able to locate various parts of the program
Dialogue: 0,0:33:16.76,0:33:22.16,English,,0,0,0,,And some information for the linker to tell it that this is a globally defined function
Dialogue: 0,0:33:22.56,0:33:27.42,English,,0,0,0,,And various other things that you don't really need to at least think about initially
Dialogue: 0,0:33:27.78,0:33:32.88,English,,0,0,0,,So we sort of take those out of the program just to make them more readable
Dialogue: 0,0:33:33.26,0:33:37.22,English,,0,0,0,,But if you ever do this yourself you'll find this crud in there
Dialogue: 0,0:33:37.22,0:33:41.48,English,,0,0,0,,And we don't want you to get like, oh my gosh this wasn't in the book I don't know what to do with it
Dialogue: 0,0:33:46.72,0:33:48.44,English,,0,0,0,,So let's go back
Dialogue: 0,0:33:58.04,0:34:04.32,English,,0,0,0,,The other thing is people are learning on data lab is shark versus non shark it makes a difference
Dialogue: 0,0:34:04.56,0:34:11.32,English,,0,0,0,,And even like this is a MAC computer and I can run got gcc installed
Dialogue: 0,0:34:11.92,0:34:14.62,English,,0,0,0,,And it generates its intel processor in there
Dialogue: 0,0:34:15.18,0:34:19.00,English,,0,0,0,,But it's not directly compatible with linux code so
Dialogue: 0,0:34:19.44,0:34:21.22,English,,0,0,0,,It's pretty important for this course
Dialogue: 0,0:34:21.22,0:34:24.60,English,,0,0,0,,We're saying just stick with the shark machines for everything you do
Dialogue: 0,0:34:29.32,0:34:32.06,English,,0,0,0,,So what are some characteristics that have assembly code
Dialogue: 0,0:34:32.06,0:34:34.72,English,,0,0,0,,Especially how do they differ from C
Dialogue: 0,0:34:35.38,0:34:39.54,English,,0,0,0,,Well first of all there is a number of different sort of integer data types
Dialogue: 0,0:34:40.02,0:34:42.96,English,,0,0,0,,Of size 1,2,4 and 8 bytes
Dialogue: 0,0:34:43.32,0:34:51.54,English,,0,0,0,,In integer data types they don't distinguish sign versus unsigned in how in how it gets stored
Dialogue: 0,0:34:51.86,0:34:57.26,English,,0,0,0,,And even at an address or a pointer is just stored as a number in a computer
Dialogue: 0,0:34:57.78,0:35:01.10,English,,0,0,0,,And doesn't have any special significance to it
Dialogue: 0,0:35:02.16,0:35:04.74,English,,0,0,0,,A floating-point is handled in a very different way
Dialogue: 0,0:35:04.74,0:35:07.20,English,,0,0,0,,On the other hand with a different set of registers
Dialogue: 0,0:35:07.68,0:35:11.82,English,,0,0,0,,That I think oh talked about very briefly in one of the later lectures
Dialogue: 0,0:35:12.50,0:35:16.68,English,,0,0,0,,The program itself is in x86 it's just a series of bytes
Dialogue: 0,0:35:16.68,0:35:18.48,English,,0,0,0,,And I'll show you some examples of those
Dialogue: 0,0:35:19.30,0:35:21.88,English,,0,0,0,,And things like arrays and structs
Dialogue: 0,0:35:22.32,0:35:25.34,English,,0,0,0,,And things that you think of as fundamental datatypes
Dialogue: 0,0:35:26.00,0:35:27.82,English,,0,0,0,,Don't exist at the machine level
Dialogue: 0,0:35:27.82,0:35:31.74,English,,0,0,0,,They're sort of constructed artificially by the compiler
Dialogue: 0,0:35:31.78,0:35:37.52,English,,0,0,0,,And later in the course in these lectures we'll cross over into how that's actually done as well
Dialogue: 0,0:35:38.52,0:35:42.50,English,,0,0,0,,So some of the things you know about and see exist here
Dialogue: 0,0:35:42.86,0:35:49.42,English,,0,0,0,,And some of them are sort of have to be built up in layers on top of the assembly level program
Dialogue: 0,0:35:52.54,0:35:59.02,English,,0,0,0,,So the other thing about assembly level programming is each instruction is very very limited in what it can do it
Dialogue: 0,0:35:59.08,0:36:03.04,English,,0,0,0,,Can move data from a register to memory, from...
Dialogue: 0,0:36:03.56,0:36:08.52,English,,0,0,0,,Or can do an addition or a multiplication
Dialogue: 0,0:36:09.30,0:36:12.68,English,,0,0,0,,Or something like that but it can really basically only do one thing
Dialogue: 0,0:36:13.64,0:36:19.68,English,,0,0,0,,And so you have to write a whole if you were writing it by hand
Dialogue: 0,0:36:19.68,0:36:23.22,English,,0,0,0,,And you'd have to write a whole series of instructions to get anything done
Dialogue: 0,0:36:23.66,0:36:26.84,English,,0,0,0,,And that's part of the reason why it's really much better to what the compiler do that
Dialogue: 0,0:36:28.72,0:36:39.42,English,,0,0,0,,And we'll also see,they're sort of how things like do loops,while loops,conditionals,switch statements
Dialogue: 0,0:36:39.42,0:36:45.84,English,,0,0,0,,Those are all built up on top of some other on lower level features in the instructions
Dialogue: 0,0:36:47.54,0:36:54.36,English,,0,0,0,,So for this function of some store actually it gets encoded by a total of 14 bytes
Dialogue: 0,0:36:55.38,0:37:00.14,English,,0,0,0,,And so one thing about x86 is some instructions are as short as one byte
Dialogue: 0,0:37:00.84,0:37:07.10,English,,0,0,0,,But others can be as long as 15 bytes in the encoding and
Dialogue: 0,0:37:13.74,0:37:18.22,English,,0,0,0,,Like I said each instruction really typically only does one thing
Dialogue: 0,0:37:18.82,0:37:22.46,English,,0,0,0,,So for example and see if you see *dest=t
Dialogue: 0,0:37:23.32,0:37:26.86,English,,0,0,0,,What that will typically and not always but this sort of way to
Dialogue: 0,0:37:26.86,0:37:28.86,English,,0,0,0,,Think about that at the machine level is its
Dialogue: 0,0:37:29.30,0:37:33.54,English,,0,0,0,,T or some local value would be typically stored in a register
Dialogue: 0,0:37:34.22,0:37:38.64,English,,0,0,0,,And as you know in C, if you put star in front of it you want it referenced as a pointer
Dialogue: 0,0:37:39.04,0:37:40.62,English,,0,0,0,,And if that reference is on the left
Dialogue: 0,0:37:41.06,0:37:47.24,English,,0,0,0,,You want to store a number of value at that place where you're pointing to
Dialogue: 0,0:37:47.90,0:37:50.64,English,,0,0,0,,So what would typically happen is
Dialogue: 0,0:37:51.04,0:37:57.40,English,,0,0,0,,Dest the the actual pointer value would also be stored in a register here it's in register %rbx
Dialogue: 0,0:37:58.58,0:38:04.92,English,,0,0,0,,And I use a move instruction to say take the value from one register which is called %rax here
Dialogue: 0,0:38:05.18,0:38:08.04,English,,0,0,0,,And store it in the memory location
Dialogue: 0,0:38:08.34,0:38:10.42,English,,0,0,0,,That's specified by another register
Dialogue: 0,0:38:10.82,0:38:14.70,English,,0,0,0,,So you see the idea we'll go into more detail about
Dialogue: 0,0:38:14.70,0:38:17.36,English,,0,0,0,,All these register names and what the parentheses mean
Dialogue: 0,0:38:17.36,0:38:20.98,English,,0,0,0,,But you get the rough idea that a move instruction is saying
Dialogue: 0,0:38:22.08,0:38:26.16,English,,0,0,0,,Can refer to either a register or a memory location
Dialogue: 0,0:38:27.72,0:38:31.78,English,,0,0,0,,And the actual object code representation of this is just a three bytes
Dialogue: 0,0:38:32.00,0:38:38.48,English,,0,0,0,,Where the first byte tells it that it
Dialogue: 0,0:38:38.56,0:38:41.10,English,,0,0,0,,And we would even talk much in this course about
Dialogue: 0,0:38:41.26,0:38:46.98,English,,0,0,0,,How the instructions are encoded won't generally let programs do that for us
Dialogue: 0,0:38:47.94,0:38:51.98,English,,0,0,0,,But in this case it only takes three bytes to write that particular instruction
Dialogue: 0,0:38:53.26,0:38:57.64,English,,0,0,0,,So how can we know that kind of stuff how can we figure out that level of detail
Dialogue: 0,0:38:58.02,0:39:02.70,English,,0,0,0,,Well there's some really useful tools that let you examine machine code
Dialogue: 0,0:39:03.10,0:39:09.74,English,,0,0,0,,Even if you don't have a copy of the original C file or even the assembly code file ahead of time
Dialogue: 0,0:39:10.14,0:39:12.02,English,,0,0,0,,And there's one called a disassembler
Dialogue: 0,0:39:12.46,0:39:20.36,English,,0,0,0,,So an assembler goes from this text version of instructions to a byte level representation
Dialogue: 0,0:39:20.80,0:39:24.94,English,,0,0,0,,And the disassembler just reverses that it says here is a series of bytes
Dialogue: 0,0:39:26.08,0:39:34.08,English,,0,0,0,,And I the disassembler know that this particular byte sequence refers is a move instruction
Dialogue: 0,0:39:34.08,0:39:39.82,English,,0,0,0,,And so it will now print out on the screen to say,oh that was a move instruction
Dialogue: 0,0:39:39.82,0:39:45.34,English,,0,0,0,,And so it basically reverse engineers from the object code back to the assembly code
Dialogue: 0,0:39:45.34,0:39:48.26,English,,0,0,0,,Or something sort of like the assembly code
Dialogue: 0,0:39:48.26,0:39:56.54,English,,0,0,0,,You'll see it lost...it's very slightly different
Dialogue: 0,0:39:57.12,0:40:01.36,English,,0,0,0,,One thing also to notice I should mention about assembly code is
Dialogue: 0,0:40:02.18,0:40:05.14,English,,0,0,0,,All those you know all the names I used
Dialogue: 0,0:40:05.14,0:40:12.08,English,,0,0,0,,All the names of variables are completely lost at the assembly code level,at the machine code level
Dialogue: 0,0:40:12.16,0:40:15.10,English,,0,0,0,,Things are just during registers they're somewhere in memory
Dialogue: 0,0:40:15.50,0:40:20.16,English,,0,0,0,,The program has no understanding of your original source code at that level
Dialogue: 0,0:40:21.72,0:40:24.92,English,,0,0,0,,And so the disassembled is just a way to go backward
Dialogue: 0,0:40:25.40,0:40:26.90,English,,0,0,0,,And you can do that yourself
Dialogue: 0,0:40:27.94,0:40:37.73,English,,0,0,0,,And you'll find that useful in various contexts and to do that yourself
Dialogue: 0,0:40:38.32,0:40:40.70,English,,0,0,0,,Thanks kind of monkeying around me
Dialogue: 0,0:40:43.14,0:41:02.34,English,,0,0,0,,So if I compile the sum program
Dialogue: 0,0:41:02.34,0:41:05.40,English,,0,0,0,,So if I do the more standard thing you doing
Dialogue: 0,0:41:06.30,0:41:11.34,English,,0,0,0,,Using a compiler you say run the compiler give it some optimization
Dialogue: 0,0:41:11.86,0:41:16.22,English,,0,0,0,,Tell it what the source files are until it where to put the final executable code
Dialogue: 0,0:41:16.22,0:41:19.42,English,,0,0,0,,And I'm terribly clever I call the function sum
Dialogue: 0,0:41:20.22,0:41:22.08,English,,0,0,0,,And so sum is a binary file
Dialogue: 0,0:41:25.74,0:41:32.36,English,,0,0,0,,Of 8663 bytes, you see off on the left its mark is executable
Dialogue: 0,0:41:33.04,0:41:34.80,English,,0,0,0,,And it actually works
Dialogue: 0,0:41:35.34,0:41:37.24,English,,0,0,0,,I can add numbers together with it
Dialogue: 0,0:41:37.40,0:41:42.22,English,,0,0,0,,So that's the year two standard executable program
Dialogue: 0,0:41:43.38,0:41:44.60,English,,0,0,0,,Excuse me
Dialogue: 0,0:41:46.12,0:41:48.98,English,,0,0,0,,And if I run a program called object dump
Dialogue: 0,0:41:50.88,0:41:53.68,English,,0,0,0,,And ask it to disassemble it can do various things
Dialogue: 0,0:41:54.62,0:42:00.44,English,,0,0,0,,It will spit out a disassembled version of the program it will fly by on the screen
Dialogue: 0,0:42:00.44,0:42:05.06,English,,0,0,0,,But if I redirect that to some a file
Dialogue: 0,0:42:08.12,0:42:11.42,English,,0,0,0,,Which I already did I'll remove the old one
Dialogue: 0,0:42:18.30,0:42:19.36,English,,0,0,0,,And now I look at that
Dialogue: 0,0:42:22.02,0:42:28.12,English,,0,0,0,,You'll see that it has what I described as is the disassembled representation of the program
Dialogue: 0,0:42:28.64,0:42:32.26,English,,0,0,0,,Including some files that you didn't some functions that you didn't write
Dialogue: 0,0:42:32.58,0:42:41.12,English,,0,0,0,,Has ones that are sort of the low-level functions that are used in the initial startup of a program called in it
Dialogue: 0,0:42:48.52,0:42:52.22,English,,0,0,0,,But here somewhere in the middle of it you'll see go and behold is
Dialogue: 0,0:42:52.58,0:42:57.38,English,,0,0,0,,That program,that function some store that got compiled
Dialogue: 0,0:42:58.12,0:43:08.56,English,,0,0,0,,And you can see that what it did was it took this 14 bytes from the original that the object code
Dialogue: 0,0:43:09.22,0:43:14.57,English,,0,0,0,,And it picked those apart and came back with what instructions those bytes in code
Dialogue: 0,0:43:14.88,0:43:18.18,English,,0,0,0,,So for example the push instruction only takes a single byte
Dialogue: 0,0:43:19.06,0:43:21.92,English,,0,0,0,,The move as you saw before takes three bytes
Dialogue: 0,0:43:22.88,0:43:31.64,English,,0,0,0,,This call because it has to give the location of where to call is a five byte instruction and so forth
Dialogue: 0,0:43:34.28,0:43:37.54,English,,0,0,0,,But again the disassembler didn't have access to the source code
Dialogue: 0,0:43:37.54,0:43:39.46,English,,0,0,0,,It didn't have access even to the assembly code
Dialogue: 0,0:43:39.46,0:43:43.92,English,,0,0,0,,It figured this out just by the bytes in the actual object code file
Dialogue: 0,0:43:45.78,0:43:51.02,English,,0,0,0,,So this is the way if you ever want to know actually the byte level encoding
Dialogue: 0,0:43:51.40,0:43:52.80,English,,0,0,0,,This is how you figure it out
Dialogue: 0,0:43:53.58,0:44:02.09,English,,0,0,0,,Is to run a program,run it through an assembler get object code and then come back out with
Dialogue: 0,0:44:03.64,0:44:05.12,English,,0,0,0,,It there's another way you can do it
Dialogue: 0,0:44:07.50,0:44:13.28,English,,0,0,0,,Using the debugging program which you'll get to know very well in the next lab you're going to do
Dialogue: 0,0:44:15.66,0:44:17.09,English,,0,0,0,,And it's called GDB
Dialogue: 0,0:44:20.26,0:44:24.86,English,,0,0,0,,And GDB is a very powerful debugging program that
Dialogue: 0,0:44:25.10,0:44:29.83,English,,0,0,0,,You can examine step through and operate on programs in
Dialogue: 0,0:44:30.04,0:44:36.72,English,,0,0,0,,And again you can,if the source code for it's available it will make use of it
Dialogue: 0,0:44:37.24,0:44:40.92,English,,0,0,0,,But it also can be used on programs for which there's no source available
Dialogue: 0,0:44:41.34,0:44:45.12,English,,0,0,0,,But one of the features is the ability to disassemble functions in there
Dialogue: 0,0:44:45.14,0:44:50.60,English,,0,0,0,,So if I say disassemble sumstore
Dialogue: 0,0:44:52.50,0:44:56.98,English,,0,0,0,,It'll come back with something that looks a lot like what you saw from object dump
Dialogue: 0,0:44:57.76,0:45:02.48,English,,0,0,0,,A listing of the instructions and here it just shows in hex
Dialogue: 0,0:45:02.56,0:45:07.36,English,,0,0,0,,What the addresses of those different instructions are it doesn't show the byte level encoding
Dialogue: 0,0:45:08.80,0:45:16.34,English,,0,0,0,,So there's my point here is there's various tools that let you look at a program
Dialogue: 0,0:45:16.82,0:45:21.98,English,,0,0,0,,Even if it's actual representation is a binary file that you don't want to examine directly
Dialogue: 0,0:45:34.84,0:45:36.36,English,,0,0,0,,I just put this in
Dialogue: 0,0:45:43.42,0:45:47.28,English,,0,0,0,,So what this slide shows is what I just showed you on the screen
Dialogue: 0,0:45:47.28,0:45:51.08,English,,0,0,0,,Which is what the object dump program produces for this function
Dialogue: 0,0:45:53.36,0:45:57.09,English,,0,0,0,,And this is a version showing what GDB would show you for it
Dialogue: 0,0:45:57.70,0:46:01.06,English,,0,0,0,,And with GDB if you want to actually get the bytes out
Dialogue: 0,0:46:01.30,0:46:06.08,English,,0,0,0,,You can do that, you can basically for any address
Dialogue: 0,0:46:06.08,0:46:10.68,English,,0,0,0,,You can just give an address and tell it to display some number of bytes
Dialogue: 0,0:46:11.16,0:46:19.02,English,,0,0,0,,And so this rather cryptic command to GDB says examine 14 bytes in hex format
Dialogue: 0,0:46:20.00,0:46:23.40,English,,0,0,0,,Starting at the address of the function sumstore
Dialogue: 0,0:46:25.66,0:46:28.82,English,,0,0,0,,And it produced something that looks like what you see on the left
Dialogue: 0,0:46:32.88,0:46:39.02,English,,0,0,0,,In fact disassembly is a tool that can be used as part of any reverse engineering tools
Dialogue: 0,0:46:39.40,0:46:46.33,English,,0,0,0,,And I used to demo this by showing a disassembly of the windows of Microsoft Word
Dialogue: 0,0:46:46.70,0:46:49.94,English,,0,0,0,,I had a pc back then not a mac
Dialogue: 0,0:46:49.94,0:46:57.94,English,,0,0,0,,But some people and you know our slides are online and so we got some nasty grams from people saying
Dialogue: 0,0:46:58.28,0:47:02.42,English,,0,0,0,,You know you're violating the Microsoft end-user license agreement when you do that
Dialogue: 0,0:47:02.42,0:47:05.78,English,,0,0,0,,Because you're supposed to you don't know this
Dialogue: 0,0:47:05.92,0:47:08.38,English,,0,0,0,,But remember all those click through I agree things
Dialogue: 0,0:47:10.00,0:47:10.76,English,,0,0,0,,But you never read
Dialogue: 0,0:47:11.22,0:47:17.90,English,,0,0,0,,One of them is very not to try to reverse engineer any Microsoft product so
Dialogue: 0,0:47:19.68,0:47:24.62,English,,0,0,0,,So this is would technically so I've served just for modesty I blanked this out
Dialogue: 0,0:47:24.62,0:47:25.78,English,,0,0,0,,But you can actually do it
Dialogue: 0,0:47:26.10,0:47:29.22,English,,0,0,0,,If you can find where the file is it's sort of where
Dialogue: 0,0:47:29.50,0:47:32.82,English,,0,0,0,,Obscure where the actual executable files of an application
Dialogue: 0,0:47:33.90,0:47:36.84,English,,0,0,0,,My point is that word like any other
Dialogue: 0,0:47:39.42,0:47:42.30,English,,0,0,0,,Application you run is just a executable file
Dialogue: 0,0:47:42.30,0:47:46.54,English,,0,0,0,,And that executable file is just a bunch of bytes that encode instructions
Dialogue: 0,0:47:48.82,0:47:53.80,English,,0,0,0,,Okay so let's go a little bit further into this assembly level programming business
Dialogue: 0,0:47:55.16,0:47:57.16,English,,0,0,0,,So I keep talking about registers
Dialogue: 0,0:47:57.98,0:48:03.18,English,,0,0,0,,And x86-64 has this totally quirky set of registers
Dialogue: 0,0:48:03.58,0:48:07.42,English,,0,0,0,,And it's a reflection again of this sort of evolutionary history to it
Dialogue: 0,0:48:08.18,0:48:12.82,English,,0,0,0,,But you'll see that there's sixteen registers that
Dialogue: 0,0:48:12.82,0:48:15.52,English,,0,0,0,,You can use to hold integers and pointers
Dialogue: 0,0:48:16.44,0:48:22.34,English,,0,0,0,,And some of them have these sort of alphabetic names and some of them have numeric names
Dialogue: 0,0:48:23.18,0:48:24.38,English,,0,0,0,,I'll show you why in a minute
Dialogue: 0,0:48:24.88,0:48:29.60,English,,0,0,0,,And also for each register if you use the sort of %r name of it
Dialogue: 0,0:48:30.04,0:48:31.40,English,,0,0,0,,You'll get 64 bits
Dialogue: 0,0:48:32.42,0:48:35.98,English,,0,0,0,,But if you use the %e version of it.you'll get 32 bits
Dialogue: 0,0:48:36.54,0:48:43.26,English,,0,0,0,,And what you'll find in programs that manipulate long int.you'll see the use of %r
Dialogue: 0,0:48:43.72,0:48:48.36,English,,0,0,0,,And if they're just in 32-bit things you'll see code saying %e
Dialogue: 0,0:48:48.42,0:48:50.04,English,,0,0,0,,So you'll see both of these show up
Dialogue: 0,0:48:50.82,0:48:53.54,English,,0,0,0,,But and it's fairly important to remember
Dialogue: 0,0:48:54.04,0:49:00.92,English,,0,0,0,,%e version is just the low-order 32 bits of a larger %r entity
Dialogue: 0,0:49:02.90,0:49:09.08,English,,0,0,0,,And in fact it goes beyond that you can also reference the lower order 16 bits
Dialogue: 0,0:49:09.66,0:49:12.32,English,,0,0,0,,And the low order 2 bit,I'm sorry, 1 byte
Dialogue: 0,0:49:12.72,0:49:17.70,English,,0,0,0,,16 one 2 bytes and 1 byte within each of these registers as well
Dialogue: 0,0:49:19.48,0:49:22.28,English,,0,0,0,,But again think of these as like named
Dialogue: 0,0:49:23.20,0:49:28.46,English,,0,0,0,,Locations where you can store values and you can retrieve values from them
Dialogue: 0,0:49:29.32,0:49:35.84,English,,0,0,0,,And you have to you the I'm sort of personifying machine level programming here
Dialogue: 0,0:49:36.08,0:49:43.94,English,,0,0,0,,You personally will actually have to explicitly name those registers for the most part
Dialogue: 0,0:49:44.48,0:49:47.02,English,,0,0,0,,To say where things should go where they should come out of
Dialogue: 0,0:49:47.08,0:49:53.02,English,,0,0,0,,It's not like a memory where you just give a number to tell where to look for
Dialogue: 0,0:49:53.04,0:49:57.04,English,,0,0,0,,You could compute a number there actually each one is identified separately
Dialogue: 0,0:49:58.30,0:50:05.18,English,,0,0,0,,So just as a little bit of history with IA32 so back
Dialogue: 0,0:50:05.98,0:50:11.92,English,,0,0,0,,We just talked about other being 8 registers all the %e versions
Dialogue: 0,0:50:12.66,0:50:19.62,English,,0,0,0,,And one of the changes that went from IA32 to x86-64 was to double the number of registers
Dialogue: 0,0:50:20.24,0:50:22.78,English,,0,0,0,,By the way this is a really helpful thing because
Dialogue: 0,0:50:23.26,0:50:29.44,English,,0,0,0,,It was very frustrating how few registers there were in the old IA32 machines
Dialogue: 0,0:50:32.34,0:50:35.14,English,,0,0,0,,And then the as I mentioned
Dialogue: 0,0:50:37.50,0:50:44.86,English,,0,0,0,,You could actually in the old machine refer to the lower order 16 bytes of these registers
Dialogue: 0,0:50:44.86,0:50:48.50,English,,0,0,0,,And that was a legacy from the 8086 days
Dialogue: 0,0:50:49.82,0:50:57.66,English,,0,0,0,,And within the first four you could even refer to the individual to lower order or bytes in those
Dialogue: 0,0:50:58.52,0:51:03.18,English,,0,0,0,,So nowadays you can actually get to the low order byte of all of them
Dialogue: 0,0:51:03.48,0:51:08.12,English,,0,0,0,,And we just sort of got...that's covered in the book actually
Dialogue: 0,0:51:08.58,0:51:13.92,English,,0,0,0,,We don't talk about how you can get to these bytes because  that's really a legacy from back
Dialogue: 0,0:51:14.56,0:51:25.58,English,,0,0,0,,Before the 8086 was one called the 8080 which was an 8 byte machine
Dialogue: 0,0:51:30.10,0:51:38.32,English,,0,0,0,,So anyways you can see then how you got from this kind of weird state of affairs to the even weirder state
Dialogue: 0,0:51:38.34,0:51:39.66,English,,0,0,0,,That we are in today
Dialogue: 0,0:51:40.10,0:51:43.86,English,,0,0,0,,Where some of them have names and some of them have numbers
Dialogue: 0,0:51:45.88,0:51:50.22,English,,0,0,0,,And those names by the way had a reason back in ancient days
Dialogue: 0,0:51:50.90,0:51:57.40,English,,0,0,0,,They had very specific purposes and so they were given names that sort of reflected those purposes
Dialogue: 0,0:51:58.00,0:52:02.06,English,,0,0,0,,But that,that all went away years and years ago
Dialogue: 0,0:52:02.50,0:52:07.38,English,,0,0,0,,And so now these names are just legacy names have nothing to do with their purpose
Dialogue: 0,0:52:08.38,0:52:13.42,English,,0,0,0,,Now I should mention these only there are some special ...there's one special register nowadays
Dialogue: 0,0:52:15.92,0:52:19.20,English,,0,0,0,,As shown in pink here and that's called the stack pointer
Dialogue: 0,0:52:19.70,0:52:25.02,English,,0,0,0,,And that register you don't just use any old way you please it has a very specific purpose
Dialogue: 0,0:52:25.84,0:52:29.58,English,,0,0,0,,And all the other registers there's some that are slightly different than the other
Dialogue: 0,0:52:29.58,0:52:33.68,English,,0,0,0,,But for the most part they're all usable for holding program data
Dialogue: 0,0:52:35.08,0:52:39.72,English,,0,0,0,,Back in the IA32 days there was a register called the base pointer
Dialogue: 0,0:52:39.72,0:52:41.94,English,,0,0,0,,That also got used for procedures
Dialogue: 0,0:52:42.50,0:52:46.88,English,,0,0,0,,But that no longer gets used anymore either at least not usually
Dialogue: 0,0:52:48.30,0:52:53.44,English,,0,0,0,,So anyways I didn't want to i don't want to spend a lot of time on historic legacy stuff
Dialogue: 0,0:52:53.90,0:52:58.82,English,,0,0,0,,And have you memorized you know what feature was added and what model of processor
Dialogue: 0,0:52:58.82,0:53:04.04,English,,0,0,0,,But just in case you're wondering why there's these weird names for these things
Dialogue: 0,0:53:04.04,0:53:07.20,English,,0,0,0,,Just so you appreciate the fact that this is a legacy thing
Dialogue: 0,0:53:09.68,0:53:16.10,English,,0,0,0,,Okay so now we can think of it then that there's eight registers with names
Dialogue: 0,0:53:16.26,0:53:19.52,English,,0,0,0,,And there's eight registers that are indicated by some number
Dialogue: 0,0:53:20.58,0:53:23.90,English,,0,0,0,,And let's look at some of the instructions that operate on those registers
Dialogue: 0,0:53:27.84,0:53:30.70,English,,0,0,0,,And there's sort of three different some mov
Dialogue: 0,0:53:31.02,0:53:35.30,English,,0,0,0,,The mov instruction in x86 is actually can do a lot of things
Dialogue: 0,0:53:38.20,0:53:43.22,English,,0,0,0,,Because it can take different types of information or what they call operands
Dialogue: 0,0:53:43.98,0:53:49.46,English,,0,0,0,,So the source is some where you're copying from the source to the destination
Dialogue: 0,0:53:51.04,0:53:53.42,English,,0,0,0,,The source can be some what's called an immediate
Dialogue: 0,0:53:53.42,0:53:56.28,English,,0,0,0,,It's actually a number that's baked into the program
Dialogue: 0,0:53:56.78,0:53:59.82,English,,0,0,0,,That you want to copy into some other location
Dialogue: 0,0:54:00.74,0:54:06.76,English,,0,0,0,,A register we've talked about is one a specially named memory of locations
Dialogue: 0,0:54:07.10,0:54:12.38,English,,0,0,0,,And memory is the array of bytes that you typically you have to specify what's the address
Dialogue: 0,0:54:12.94,0:54:19.96,English,,0,0,0,,That you're either reading from if it's the source are you writing to if it's the destination
Dialogue: 0,0:54:22.62,0:54:25.96,English,,0,0,0,,And so the mov instruction gives you all these possibilities
Dialogue: 0,0:54:26.90,0:54:33.30,English,,0,0,0,,An immediate value can be written to a register or directly to memory
Dialogue: 0,0:54:34.18,0:54:38.26,English,,0,0,0,,A register value can be copied to another register or written to memory
Dialogue: 0,0:54:39.14,0:54:44.36,English,,0,0,0,,Or you can take a value from memory read it from memory and copy it to a register
Dialogue: 0,0:54:45.20,0:54:50.24,English,,0,0,0,,So if you think of wait shouldn't there be nine different combinations here well
Dialogue: 0,0:54:50.52,0:54:51.04,English,,0,0,0,,No
Dialogue: 0,0:54:51.44,0:54:56.52,English,,0,0,0,,Because it doesn't make sense to have an immediate value as a destination right, it's a constant
Dialogue: 0,0:54:57.16,0:55:02.38,English,,0,0,0,,And also just for sort of the sake of convenience for the hardware designers
Dialogue: 0,0:55:02.84,0:55:06.54,English,,0,0,0,,It doesn't let you directly copy from one memory location to another
Dialogue: 0,0:55:07.00,0:55:09.20,English,,0,0,0,,What you have to do is use two instructions
Dialogue: 0,0:55:09.40,0:55:13.82,English,,0,0,0,,One to copy from memory to read it from memory copy it to a register
Dialogue: 0,0:55:15.72,0:55:19.36,English,,0,0,0,,And the second to take that value in the register and write it to memory
Dialogue: 0,0:55:20.32,0:55:24.90,English,,0,0,0,,So that's why there's this only five possibilities
Dialogue: 0,0:55:26.40,0:55:31.84,English,,0,0,0,,And so each of these actual five combinations you'll see in some form or another
Dialogue: 0,0:55:32.64,0:55:37.00,English,,0,0,0,,So for example if I take a constant value and copy it to a register
Dialogue: 0,0:55:37.72,0:55:43.56,English,,0,0,0,,It's a little like you can think of register as a sort of the temporary data that You're operating on right now
Dialogue: 0,0:55:44.38,0:55:48.30,English,,0,0,0,,So it's a way of sort of of assigning a constant value to a temporary
Dialogue: 0,0:55:50.08,0:55:54.04,English,,0,0,0,,Similarly if you're have a memory as your destination
Dialogue: 0,0:55:54.04,0:55:58.04,English,,0,0,0,,It's like storing a constant value in memory somewhere
Dialogue: 0,0:55:59.80,0:56:02.54,English,,0,0,0,,If you're copying from one register to another
Dialogue: 0,0:56:02.54,0:56:08.44,English,,0,0,0,,It's sort of like copying one temporary value to another one  register to memory
Dialogue: 0,0:56:08.56,0:56:13.64,English,,0,0,0,,It's as if you it's sort of like storing to an address
Dialogue: 0,0:56:14.04,0:56:17.92,English,,0,0,0,,So a pointer dereference where the pointer is on the left side the dereference
Dialogue: 0,0:56:19.34,0:56:22.34,English,,0,0,0,,And memory to register is the opposite
Dialogue: 0,0:56:22.44,0:56:27.64,English,,0,0,0,,You're reading from some location into a temporary position
Dialogue: 0,0:56:30.06,0:56:34.38,English,,0,0,0,,So these you see all five versions get used in some form or another
Dialogue: 0,0:56:36.62,0:56:40.20,English,,0,0,0,,So now let's talk about how we write these up pointers
Dialogue: 0,0:56:40.78,0:56:46.55,English,,0,0,0,,How we specify either a source or a destination for a memory reference
Dialogue: 0,0:56:47.41,0:56:51.82,English,,0,0,0,,And you already saw one version of this in fact in some of the code
Dialogue: 0,0:56:52.06,0:56:54.80,English,,0,0,0,,When you put the name of a register in parentheses
Dialogue: 0,0:56:55.64,0:57:00.32,English,,0,0,0,,That's just saying use this register whatever is in that that's an address
Dialogue: 0,0:57:00.88,0:57:03.92,English,,0,0,0,,And use that address to reference some memory location
Dialogue: 0,0:57:06.42,0:57:12.58,English,,0,0,0,,And so you'll see something like this is equivalent of dereferencing a pointer and putting it in a temporary
Dialogue: 0,0:57:13.60,0:57:16.10,English,,0,0,0,,You're also allowed to do a little bit of arithmetic
Dialogue: 0,0:57:16.82,0:57:22.48,English,,0,0,0,,To derive an address from some collection of registers and other constant values
Dialogue: 0,0:57:23.22,0:57:26.18,English,,0,0,0,,So if you see a number it's called the displacement D
Dialogue: 0,0:57:27.02,0:57:33.68,English,,0,0,0,,In front of this parenthesis it means to offset not use the address that's in the register
Dialogue: 0,0:57:34.06,0:57:36.18,English,,0,0,0,,But add or subtract some number from it
Dialogue: 0,0:57:36.56,0:57:40.34,English,,0,0,0,,To get an address that's just slightly off of it by some fixed amount
Dialogue: 0,0:57:40.94,0:57:44.76,English,,0,0,0,,And that we'll see is fairly useful for accessing different data structures
Dialogue: 0,0:57:47.92,0:57:50.58,English,,0,0,0,,So here's an example of a very simple function that
Dialogue: 0,0:57:50.84,0:57:55.90,English,,0,0,0,,We can understand everything about it already
Dialogue: 0,0:57:56.32,0:57:58.60,English,,0,0,0,,Because we know what the mov instruction does
Dialogue: 0,0:57:59.08,0:58:05.28,English,,0,0,0,,And that's the sort of classic swapping of two values that are stored in memory
Dialogue: 0,0:58:05.90,0:58:10.62,English,,0,0,0,,So my point my arguments are two pointers called xp and yp
Dialogue: 0,0:58:11.26,0:58:15.62,English,,0,0,0,,And I'm going to dereference those pointers I'm going to read from memory into registers
Dialogue: 0,0:58:16.76,0:58:20.82,English,,0,0,0,,And then I'm going to copy back to to memory
Dialogue: 0,0:58:20.82,0:58:24.64,English,,0,0,0,,But reversing the the two destinations
Dialogue: 0,0:58:25.76,0:58:30.46,English,,0,0,0,,And so as you can imagine it,it lines up to be for mov instructions
Dialogue: 0,0:58:30.54,0:58:33.16,English,,0,0,0,,That correspond to these four references
Dialogue: 0,0:58:34.58,0:58:40.00,English,,0,0,0,,And the final one ret just won't learn more about functions  and how they're called
Dialogue: 0,0:58:40.00,0:58:47.50,English,,0,0,0,,But just think of the read is it gets you it returns from wherever the calling position was
Dialogue: 0,0:58:51.92,0:58:57.00,English,,0,0,0,,And so let's look at more detail at the actual code then
Dialogue: 0,0:58:58.04,0:59:09.26,English,,0,0,0,,And so it turns out with the (64)x86-64 the arguments always come in some specific registers
Dialogue: 0,0:59:09.74,0:59:11.58,English,,0,0,0,,And the ones to remember for today is
Dialogue: 0,0:59:11.62,0:59:17.00,English,,0,0,0,,%rdi will be the first argument register and %rsi will be the second argument register
Dialogue: 0,0:59:17.42,0:59:20.56,English,,0,0,0,,There can be up to six of these and we'll go into more of that later
Dialogue: 0,0:59:21.62,0:59:25.40,English,,0,0,0,,So those two registers represent the values of xp and yp
Dialogue: 0,0:59:25.40,0:59:31.38,English,,0,0,0,,Those are set before when this before the function is actually begins executing
Dialogue: 0,0:59:31.40,0:59:34.42,English,,0,0,0,,That's set by the part of the code that calls this function
Dialogue: 0,0:59:36.10,0:59:41.68,English,,0,0,0,,And those will be pointers so what they are is they contain addresses that specifying locations in memory
Dialogue: 0,0:59:43.34,0:59:47.42,English,,0,0,0,,And then within the code the compiler just came up with its own ideas
Dialogue: 0,0:59:47.44,0:59:52.74,English,,0,0,0,,How to use different registers for temporary data by whatever
Dialogue: 0,0:59:53.24,0:59:57.40,English,,0,0,0,,What's known as the register allocation algorithm it uses
Dialogue: 0,0:59:58.00,1:00:02.52,English,,0,0,0,,And we don't really care,we just want to what...we'll want to do is figure out what it's doing
Dialogue: 0,1:00:03.82,1:00:11.40,English,,0,0,0,,And we'll see that a register is %rax is being used to hold the value t0 and %rax the value t1
Dialogue: 0,1:00:14.50,1:00:19.94,English,,0,0,0,,Now so let's get actually concrete here and this is very detailed
Dialogue: 0,1:00:20.18,1:00:22.78,English,,0,0,0,,But I think it's important that you understand
Dialogue: 0,1:00:23.62,1:00:28.54,English,,0,0,0,,Sort of you can almost simulate the execution of some instructions by yourself
Dialogue: 0,1:00:29.18,1:00:31.20,English,,0,0,0,,You're going to really have to know this stuff
Dialogue: 0,1:00:31.86,1:00:34.62,English,,0,0,0,,So what each of these instructions is doing
Dialogue: 0,1:00:34.62,1:00:38.20,English,,0,0,0,,And how it works and really have that wired into you pretty well
Dialogue: 0,1:00:38.96,1:00:49.38,English,,0,0,0,,So let's make up an example let's imagine that the two addresses that are used for these two pointers are in 0x120 and 0x100
Dialogue: 0,1:00:49.78,1:00:53.04,English,,0,0,0,,By the way those would not be typical addresses
Dialogue: 0,1:00:53.54,1:00:58.00,English,,0,0,0,,They're way too small a number but it's much easier to use them as an illustration
Dialogue: 0,1:00:59.12,1:01:03.30,English,,0,0,0,,And let's suppose that one of them held the value 123 and the other 456
Dialogue: 0,1:01:05.74,1:01:10.27,English,,0,0,0,,So the first instruction says use %rdi as an address
Dialogue: 0,1:01:11.02,1:01:15.22,English,,0,0,0,,Copy from that memory location and store the result in register %rax
Dialogue: 0,1:01:16.04,1:01:18.54,English,,0,0,0,,So %rdi is 0x120
Dialogue: 0,1:01:19.02,1:01:24.44,English,,0,0,0,,I'll read from that address I'll read the value 123 and store it and register %rax
Dialogue: 0,1:01:24.86,1:01:26.76,English,,0,0,0,,These are all by the way 8 byte values
Dialogue: 0,1:01:28.14,1:01:30.54,English,,0,0,0,,And I'm just sort of glossing over that part of it
Dialogue: 0,1:01:30.54,1:01:37.18,English,,0,0,0,,But the q refers to what in intel terminology is a quad word
Dialogue: 0,1:01:37.88,1:01:43.06,English,,0,0,0,,A word because it goes back to the 8086 is 16 bits 2 bytes
Dialogue: 0,1:01:44.18,1:01:53.14,English,,0,0,0,,A long word is 32 bits and a quad word is 64 bits
Dialogue: 0,1:01:53.30,1:01:56.94,English,,0,0,0,,That's just their terminology and we're stuck with it
Dialogue: 0,1:01:58.42,1:02:01.54,English,,0,0,0,,Ok so that one instruction had that effect
Dialogue: 0,1:02:02.30,1:02:09.38,English,,0,0,0,,The second instruction does the same thing but using %rsi which holds 0x100 as an address
Dialogue: 0,1:02:09.38,1:02:12.80,English,,0,0,0,,And so it copies for 456 into %rdx
Dialogue: 0,1:02:14.52,1:02:19.54,English,,0,0,0,,And then the third instruction is writing back to memory
Dialogue: 0,1:02:19.68,1:02:21.76,English,,0,0,0,,So its source is register %rdx
Dialogue: 0,1:02:22.98,1:02:27.68,English,,0,0,0,,The destination has the address of %rdi which is 0x120
Dialogue: 0,1:02:28.24,1:02:29.98,English,,0,0,0,,It's storing that back in memory
Dialogue: 0,1:02:30.64,1:02:35.90,English,,0,0,0,,And finally the this fourth instruction does the other part of the right
Dialogue: 0,1:02:36.58,1:02:40.66,English,,0,0,0,,So you see these four instructions to read from memory into registers
Dialogue: 0,1:02:40.82,1:02:44.60,English,,0,0,0,,Two of them wrote from registers back to memory and that's the whole function
Dialogue: 0,1:02:47.62,1:02:52.14,English,,0,0,0,,And you can see it this move instruction is doing all the work here
Dialogue: 0,1:02:55.24,1:03:00.18,English,,0,0,0,,So we've shown that example just showed this very simple memory referencing
Dialogue: 0,1:03:00.72,1:03:03.10,English,,0,0,0,,That's designated by the parentheses
Dialogue: 0,1:03:03.90,1:03:07.96,English,,0,0,0,,And as I mentioned you can do a version where you put a displacement there too
Dialogue: 0,1:03:09.10,1:03:11.96,English,,0,0,0,,And in fact there's a much more elaborate form and
Dialogue: 0,1:03:11.96,1:03:15.56,English,,0,0,0,,We'll see that this is useful for implementing array references
Dialogue: 0,1:03:16.32,1:03:18.86,English,,0,0,0,,Where there can be actually two registers involved
Dialogue: 0,1:03:22.14,1:03:26.04,English,,0,0,0,,And there can be a displacement which is a constant offset
Dialogue: 0,1:03:26.54,1:03:29.66,English,,0,0,0,,And a scale factor which will be 1,2,4,8
Dialogue: 0,1:03:30.58,1:03:35.68,English,,0,0,0,,And the general idea of it is to take Ri register
Dialogue: 0,1:03:35.98,1:03:40.42,English,,0,0,0,,That I'm referring to S sub, that's known as an index register
Dialogue: 0,1:03:40.84,1:03:43.14,English,,0,0,0,,You multiply it by the scale factor
Dialogue: 0,1:03:45.16,1:03:50.12,English,,0,0,0,,I'll you add the value of Rb register Rb
Dialogue: 0,1:03:50.64,1:03:53.30,English,,0,0,0,,And you also add the constant displacement
Dialogue: 0,1:03:53.86,1:04:00.12,English,,0,0,0,,And these have a Rb refers to base our Ri index and S is scale
Dialogue: 0,1:04:00.42,1:04:04.04,English,,0,0,0,,And it turns out this will be the sort of natural way to implement array referencing
Dialogue: 0,1:04:04.12,1:04:07.16,English,,0,0,0,,It will make a lot more sense when we talk about arrays
Dialogue: 0,1:04:07.86,1:04:11.46,English,,0,0,0,,But basically you can think of is if this is an array index
Dialogue: 0,1:04:12.96,1:04:17.92,English,,0,0,0,,I have to typically scale it by however many bytes my data type is
Dialogue: 0,1:04:17.94,1:04:23.52,English,,0,0,0,,So if it's an int i have to scale it by four if it's a long i have to scale it by eight
Dialogue: 0,1:04:24.04,1:04:26.08,English,,0,0,0,,So that's where these scale factors will come in
Dialogue: 0,1:04:30.22,1:04:33.92,English,,0,0,0,,And basically the the format in the assembly code
Dialogue: 0,1:04:33.92,1:04:39.60,English,,0,0,0,,Lets you eliminate some of these fields if they're not being used
Dialogue: 0,1:04:40.26,1:04:44.94,English,,0,0,0,,So you'll and we already saw the single parenthesis a sort of a reduced version of this form
Dialogue: 0,1:04:46.98,1:04:50.84,English,,0,0,0,,So let's just do some examples of these address computations
Dialogue: 0,1:04:52.22,1:04:57.08,English,,0,0,0,,And let's imagine that register %rdx hold text f with three zeros(0xf000)
Dialogue: 0,1:04:57.68,1:05:00.56,English,,0,0,0,,And %rcx holds a one with two zeros(0x0100)
Dialogue: 0,1:05:01.48,1:05:06.58,English,,0,0,0,,So if I rather than doing one at a time
Dialogue: 0,1:05:06.58,1:05:12.18,English,,0,0,0,,You can see each of these I'm taking %rdx which is 0xf000 + 0x8
Dialogue: 0,1:05:12.72,1:05:14.48,English,,0,0,0,,And so that's 0xf008
Dialogue: 0,1:05:15.30,1:05:18.92,English,,0,0,0,,Here iI'm adding together registers %rdx and %rcx
Dialogue: 0,1:05:19.44,1:05:21.66,English,,0,0,0,,And that gives me 0xf100
Dialogue: 0,1:05:22.38,1:05:25.90,English,,0,0,0,,I'm doing the same here except that I'm scaling %rcx by 4
Dialogue: 0,1:05:26.52,1:05:32.16,English,,0,0,0,,So 4*0x100 is 0x400 and I'm adding that to 0xf
Dialogue: 0,1:05:34.04,1:05:38.64,English,,0,0,0,,And here I'm taking %rdx which is 0xf000
Dialogue: 0,1:05:39.14,1:05:43.32,English,,0,0,0,,If I double that I get 0x1e000
Dialogue: 0,1:05:43.32,1:05:47.86,English,,0,0,0,,If you think about shifting an 0xf to the left 1 you get a 1
Dialogue: 0,1:05:48.28,1:05:50.74,English,,0,0,0,,And then it goes 1110
Dialogue: 0,1:05:51.90,1:05:52.84,English,,0,0,0,,And that's an 0xe
Dialogue: 0,1:05:53.82,1:05:57.40,English,,0,0,0,,Ok and then I'm adding this displacement of 0x80 to it
Dialogue: 0,1:05:58.00,1:06:03.14,English,,0,0,0,,So the point of this is all of this is arithmetic it's all using whatever is in the register
Dialogue: 0,1:06:04.06,1:06:07.66,English,,0,0,0,,And there's some rules for how you combine this and get an address
Dialogue: 0,1:06:08.20,1:06:11.66,English,,0,0,0,,And then that's being used to either read or write some memory location
Dialogue: 0,1:06:15.18,1:06:18.20,English,,0,0,0,,Okay so now what is a final part of that today
Dialogue: 0,1:06:19.02,1:06:21.40,English,,0,0,0,,I'll go through some arithmetic
Dialogue: 0,1:06:22.40,1:06:26.50,English,,0,0,0,,And one of the things that will be sure to confuse you and drive you crazy
Dialogue: 0,1:06:26.56,1:06:30.36,English,,0,0,0,,Make you be sending email to the staff for explanation
Dialogue: 0,1:06:30.88,1:06:33.22,English,,0,0,0,,Is an instruction called load effective address
Dialogue: 0,1:06:34.84,1:06:37.56,English,,0,0,0,,And the reason is its purpose in life is to do
Dialogue: 0,1:06:38.20,1:06:42.28,English,,0,0,0,,Basically the ampersand operation of C to compute an address
Dialogue: 0,1:06:43.00,1:06:46.96,English,,0,0,0,,Based on some whatever you want to compute an address from
Dialogue: 0,1:06:48.56,1:06:54.58,English,,0,0,0,,But it also turns out to be a pretty handy way to do arithmetic and the C compiler likes to use it
Dialogue: 0,1:06:55.52,1:07:05.38,English,,0,0,0,,So in particular,it looks the the format of it looks like a mov instruction there's a source and a destination
Dialogue: 0,1:07:06.34,1:07:08.54,English,,0,0,0,,But the destination has to be a register
Dialogue: 0,1:07:09.64,1:07:12.94,English,,0,0,0,,And the source will be one of these memory references
Dialogue: 0,1:07:15.00,1:07:16.80,English,,0,0,0,,So it looks like a mov instruction
Dialogue: 0,1:07:16.82,1:07:20.18,English,,0,0,0,,It looks like you're doing some address computation
Dialogue: 0,1:07:20.18,1:07:23.50,English,,0,0,0,,Then you're reading from memory and storing it to a register
Dialogue: 0,1:07:24.02,1:07:28.06,English,,0,0,0,,But what it actually does is it does that address computation
Dialogue: 0,1:07:28.56,1:07:33.64,English,,0,0,0,,And then it actually writes that address not the memory value
Dialogue: 0,1:07:33.64,1:07:38.26,English,,0,0,0,,But the value of got that got computed directly to the register
Dialogue: 0,1:07:39.08,1:07:42.38,English,,0,0,0,,Which is what you want to do here remember the ampersand operation is
Dialogue: 0,1:07:42.96,1:07:45.96,English,,0,0,0,,Give me the address of some place give me a pointer
Dialogue: 0,1:07:46.38,1:07:50.04,English,,0,0,0,,That designates some location
Dialogue: 0,1:07:51.00,1:07:56.96,English,,0,0,0,,So for example this is fairly typical in C code if you say multiply x by 12
Dialogue: 0,1:07:57.76,1:08:04.44,English,,0,0,0,,It will turn it into a address computation
Dialogue: 0,1:08:04.50,1:08:08.62,English,,0,0,0,,And this is just a clever way to compute three times %rdi
Dialogue: 0,1:08:09.58,1:08:13.24,English,,0,0,0,,It adds %rdi + 2*%rdi
Dialogue: 0,1:08:13.30,1:08:16.74,English,,0,0,0,,So that's 3*%rdi and stores it in %rax
Dialogue: 0,1:08:17.96,1:08:24.68,English,,0,0,0,,And then salq means shift left by two
Dialogue: 0,1:08:25.18,1:08:28.80,English,,0,0,0,,And so you remember shifting left by two is like multiplying by four
Dialogue: 0,1:08:29.44,1:08:36.90,English,,0,0,0,,So the first value computed 3*x. i shift that left four by two positions and i have 12*x
Dialogue: 0,1:08:39.84,1:08:45.80,English,,0,0,0,,So that's a very special the lea,but you'll see it all over the place so you need to be ready for it
Dialogue: 0,1:08:46.40,1:08:50.48,English,,0,0,0,,These other ones look more like what you'd expect for arithmetic instructions
Dialogue: 0,1:08:50.48,1:08:55.28,English,,0,0,0,,They have names like add and subtract and multiply and so forth
Dialogue: 0,1:08:55.76,1:08:59.10,English,,0,0,0,,And they all have the same general format that they have two arguments
Dialogue: 0,1:09:00.24,1:09:04.15,English,,0,0,0,,And what's called the destination is actually also a source
Dialogue: 0,1:09:05.04,1:09:08.74,English,,0,0,0,,It's a little like in c if you say x plus equals y
Dialogue: 0,1:09:09.50,1:09:15.44,English,,0,0,0,,It's saying take the value of x add the value of y and then store the result in x
Dialogue: 0,1:09:15.78,1:09:18.30,English,,0,0,0,,And now the destination is like that
Dialogue: 0,1:09:19.28,1:09:24.86,English,,0,0,0,,The other thing that's weird is that the operands are in the inverse order from where you'd expect them to be
Dialogue: 0,1:09:25.58,1:09:29.96,English,,0,0,0,,So the source comes first in the destination comes last and that's important to remember
Dialogue: 0,1:09:33.22,1:09:37.50,English,,0,0,0,,And other thing you'll see that there's nothing special here whether it's a...
Dialogue: 0,1:09:37.98,1:09:41.64,English,,0,0,0,,Except that this is a arithmetic shift and this is a logical shift
Dialogue: 0,1:09:42.42,1:09:44.54,English,,0,0,0,,Of whether it's a signed or unsigned value
Dialogue: 0,1:09:44.54,1:09:49.16,English,,0,0,0,,Because you remember the bit level behavior of these two instructions is the same
Dialogue: 0,1:09:52.44,1:09:54.82,English,,0,0,0,,And then there's a series of instructions that are used
Dialogue: 0,1:09:55.24,1:10:01.74,English,,0,0,0,,That are just take one operand increment decrement a negate and not
Dialogue: 0,1:10:02.52,1:10:07.18,English,,0,0,0,,Not is not is like the tilde operation and see not the exclamation
Dialogue: 0,1:10:09.28,1:10:10.92,English,,0,0,0,,So those are the basic instructions
Dialogue: 0,1:10:11.52,1:10:14.60,English,,0,0,0,,And again now we can actually look at some programs and understand them
Dialogue: 0,1:10:14.62,1:10:19.66,English,,0,0,0,,And here's one that just does a bunch of junk of arithmetic instructions
Dialogue: 0,1:10:20.30,1:10:23.12,English,,0,0,0,,And it converts into the following assembly code
Dialogue: 0,1:10:23.82,1:10:29.52,English,,0,0,0,,And you see it's using this lea instruction multiple times to do addition in various forms
Dialogue: 0,1:10:31.20,1:10:35.52,English,,0,0,0,,And it also has shifting and it has multiplication
Dialogue: 0,1:10:36.06,1:10:39.58,English,,0,0,0,,You saw in the original code I just have addition and multiplication
Dialogue: 0,1:10:40.80,1:10:46.64,English,,0,0,0,,Here I have various instructions, I only have one multiply here whereas, I had two there
Dialogue: 0,1:10:46.64,1:10:52.26,English,,0,0,0,,So the compiler is sort of scrambling things around trying to find clever ways to implement
Dialogue: 0,1:10:52.70,1:10:59.94,English,,0,0,0,,What you're asking for using less complex expensive less time-consuming instructions
Dialogue: 0,1:11:03.12,1:11:08.00,English,,0,0,0,,And if you sort of go through this code carefully what you'll find is
Dialogue: 0,1:11:09.64,1:11:14.74,English,,0,0,0,,That this instruction here corresponds to this computation of t1
Dialogue: 0,1:11:14.82,1:11:19.50,English,,0,0,0,,It's adding two values and giving it a new name it's putting in %rax
Dialogue: 0,1:11:20.06,1:11:27.74,English,,0,0,0,,Similarly this one is adding z to t1 and storing it back in %rax
Dialogue: 0,1:11:28.66,1:11:31.92,English,,0,0,0,,The x+4 doesn't show up directly here
Dialogue: 0,1:11:32.66,1:11:35.64,English,,0,0,0,,It turns out what it does is it jumps right at head to here
Dialogue: 0,1:11:35.74,1:11:37.96,English,,0,0,0,,And multiply y by 48
Dialogue: 0,1:11:38.66,1:11:43.00,English,,0,0,0,,It does it by first computing 3y like we saw
Dialogue: 0,1:11:44.24,1:11:47.76,English,,0,0,0,,And computing shifting that left by 4
Dialogue: 0,1:11:48.04,1:11:50.36,English,,0,0,0,,Because 3 *16=48
Dialogue: 0,1:11:51.18,1:11:54.90,English,,0,0,0,,And then the 4 here that x + 4 actually shows up here
Dialogue: 0,1:11:55.62,1:12:02.42,English,,0,0,0,,It just uses the displacement field of this computation to add 4 to some other values
Dialogue: 0,1:12:04.00,1:12:06.30,English,,0,0,0,,And so this is label then these comments show
Dialogue: 0,1:12:06.32,1:12:09.46,English,,0,0,0,,How these correspond to the program and these registers show it
Dialogue: 0,1:12:10.14,1:12:12.36,English,,0,0,0,,So the important thing to get from here
Dialogue: 0,1:12:12.42,1:12:15.70,English,,0,0,0,,You will want to actually go back through this and make sure you believe
Dialogue: 0,1:12:16.32,1:12:19.22,English,,0,0,0,,That the comments are correct
Dialogue: 0,1:12:20.92,1:12:24.18,English,,0,0,0,,But it's very important for you to figure out this lea instruction
Dialogue: 0,1:12:24.26,1:12:26.70,English,,0,0,0,,Otherwise you're just going to be hopelessly confused
Dialogue: 0,1:12:27.48,1:12:34.82,English,,0,0,0,,And it's also important to understand that the code that gets generated will correctly implement your function
Dialogue: 0,1:12:35.14,1:12:41.34,English,,0,0,0,,But it might not exactly replicate at a low level the the exact sequence of operations
Dialogue: 0,1:12:41.34,1:12:42.70,English,,0,0,0,,You specified at a high level
Dialogue: 0,1:12:45.08,1:12:53.46,English,,0,0,0,,So that will just to summarize then you've already gotten a glimpse then of what this very odd a world of machine programming is
Dialogue: 0,1:12:53.46,1:12:56.08,English,,0,0,0,,And how different it is from C code already
Dialogue: 0,1:12:57.46,1:13:03.82,English,,0,0,0,,It's all so you've already seen that x86 is weird like I said it's English
Dialogue: 0,1:13:04.44,1:13:11.40,English,,0,0,0,,It's not a latin, it's not well designed and but you just got to deal with that
Dialogue: 0,1:13:12.74,1:13:19.22,English,,0,0,0,,So that's your beginning to machine level programming.Thanks a lot
